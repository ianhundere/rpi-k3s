apiVersion: v1
kind: ConfigMap
metadata:
 name: quixit-scripts
 namespace: quixit
 labels:
  app: quixit
data:
 init-quixit.sh: |
  #!/usr/bin/env sh

  # Create logs directory
  mkdir -p /logs

  /filebrowser config init --database /database/filebrowser.db

  /filebrowser config set \
      --database /database/filebrowser.db \
      --port 44301 \
      --address 0.0.0.0 \
      --baseurl "/" \
      --root "/srv" \
      --branding.name "${QUIXIT_HOST}" \
      --branding.disableExternal \
      --branding.disableUsedPercentage \
      --branding.files "/branding" \
      --signup \
      --log "/logs/filebrowser.log"

  # create main quixit directory
  mkdir -p /srv/quixit

  # create welcome file
  echo "WELCOME TO QUIXIT MUSIC COLLABORATION CHALLENGE" > /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 12 days, and then receive constructive criticism from fellow peers on their track." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "how it works:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "1. upload samples during the sample submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "2. download the sample pack when it becomes available" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "3. create your track using only the provided samples" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "4. upload your finished track during the song submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "5. download and listen to everyone's tracks when the challenge is complete" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "all previous quixit challenges are available in read-only mode." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "if you enjoy quixit, please consider supporting the project with a donation:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
  echo "https://www.paypal.com/donate/?hosted_button_id=T73SWSVDGBFH8" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt

  # create or update admin user
  /filebrowser users add "${QUIXIT_USER}" "${QUIXIT_PW}" --perm.admin --database /database/filebrowser.db || \
  /filebrowser users update "${QUIXIT_USER}" --password "${QUIXIT_PW}" --database /database/filebrowser.db

  # set default permissions for new users
  /filebrowser config set \
      --database /database/filebrowser.db \
      --scope "/quixit" \
      --perm.admin=false \
      --perm.execute=false \
      --perm.create=true \
      --perm.rename=false \
      --perm.modify=true \
      --perm.delete=false \
      --perm.share=false \
      --perm.download=true

  # start filebrowser
  exec /filebrowser --port 44301 --database /database/filebrowser.db --log "/logs/filebrowser.log"
 wrapper.sh: |
  #!/bin/sh

  # Create logs directory
  mkdir -p /logs

  # Install required tools
  apk add --no-cache inotify-tools util-linux file

  # Create the watcher script
  cat > /tmp/watcher.sh << 'EOF'
  #!/bin/sh

  # Set up logging
  LOG_FILE=/logs/watcher.log

  # basic log size management function
  manage_log_size() {
    # check if log file exists and is larger than 50MB
    if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE") -gt 52428800 ]; then
      echo "[$(date)] log file exceeds 50MB, truncating to last 10MB" > "$LOG_FILE.tmp"
      tail -c 10485760 "$LOG_FILE" >> "$LOG_FILE.tmp"
      mv "$LOG_FILE.tmp" "$LOG_FILE"
      echo "[$(date)] log file truncated" >> "$LOG_FILE"
    fi
  }

  # check log size every 15 minutes in the background
  (
    while true; do
      manage_log_size
      sleep 900
    done
  ) &

  log() {
    echo "[$(date)] $1" | tee -a "$LOG_FILE"
  }

  log "Starting file watcher..."

  # global variables for caching usernames
  CACHED_USERNAMES=""
  CACHE_TIMESTAMP=0
  CACHE_TTL=900  # 15 minutes in seconds

  # track recently processed files to avoid duplicate processing
  PROCESSED_FILES_DIR="/tmp/processed_files"
  mkdir -p "$PROCESSED_FILES_DIR"

  # function to check if a file was recently processed
  was_recently_processed() {
    FILE_PATH="$1"
    FILE_HASH=$(echo "$FILE_PATH" | md5sum | cut -d' ' -f1)
    MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
    
    if [ -f "$MARKER_FILE" ]; then
      # check if the marker is less than 10 seconds old
      MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
      if [ "$MARKER_AGE" -lt 10 ]; then
        log "file was processed recently ($MARKER_AGE seconds ago), skipping: $FILE_PATH"
        return 0
      fi
    fi
    
    # mark the file as processed
    touch "$MARKER_FILE"
    
    # clean up old markers (older than 1 minute)
    find "$PROCESSED_FILES_DIR" -type f -mmin +1 -delete 2>/dev/null
    
    return 1
  }

  # Function to check if a file has an allowed audio extension
  has_audio_extension() {
    FILE="$1"
    LOWERCASE_FILE=$(echo "$FILE" | tr '[:upper:]' '[:lower:]')
    
    # explicitly check for allowed extensions
    if echo "$LOWERCASE_FILE" | grep -q -E '\.wav$|\.mp3$|\.ogg$|\.flac$|\.aiff$'; then
      return 0
    fi
    
    # explicitly reject common non-audio extensions
    if echo "$LOWERCASE_FILE" | grep -q -E '\.rar$|\.zip$|\.tar$|\.gz$|\.7z$|\.txt$|\.pdf$|\.doc$|\.docx$|\.jpg$|\.jpeg$|\.png$|\.gif$'; then
      log "file has explicitly rejected extension: $FILE"
      return 1
    fi
    
    # reject any other extensions
    return 1
  }

  # function to check if a filename contains a username
  check_username_in_filename() {
    FILENAME="$1"
    log "checking if filename contains a username: $FILENAME"
    
    # check if we need to refresh the cache
    CURRENT_TIME=$(date +%s)
    CACHE_AGE=$((CURRENT_TIME - CACHE_TIMESTAMP))
    
    if [ -z "$CACHED_USERNAMES" ] || [ "$CACHE_AGE" -gt "$CACHE_TTL" ]; then
      log "username cache expired or empty, refreshing from api"
      
      # get auth token from filebrowser api
      API_URL="http://quixit.quixit:44301/api"
      ADMIN_USER="${QUIXIT_USER}"
      ADMIN_PASS="${QUIXIT_PW}"
      
      # get auth token
      TOKEN_RESPONSE=$(curl -s -X POST "$API_URL/login" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "{\"username\":\"$ADMIN_USER\",\"password\":\"$ADMIN_PASS\"}" 2>/dev/null)
      
      # check if token was obtained
      if [ -z "$TOKEN_RESPONSE" ]; then
        log "failed to get auth token, using static fallback list"
        # fallback to static list if api fails
        CACHED_USERNAMES="quixit-admin"
        # add any other known users to the static list
        log "using static usernames list: $CACHED_USERNAMES"
      else
        # get users list
        USERS_JSON=$(curl -s -X GET "$API_URL/users" \
          -H "X-Auth: $TOKEN_RESPONSE" \
          -H "Content-Type: application/json" 2>/dev/null)
        
        # extract usernames
        USERNAMES=$(echo "$USERS_JSON" | grep -o '"username":"[^"]*"' | sed 's/"username":"//g' | sed 's/"//g')
        
        # check if we got any usernames
        if [ -z "$USERNAMES" ]; then
          log "failed to get usernames from api, using static fallback list"
          CACHED_USERNAMES="quixit-admin"
          log "using static usernames list: $CACHED_USERNAMES"
        else
          log "successfully retrieved usernames from api"
          CACHED_USERNAMES="$USERNAMES"
          log "usernames: $CACHED_USERNAMES"
        fi
      fi
      
      # update cache timestamp
      CACHE_TIMESTAMP=$CURRENT_TIME
      log "updated username cache timestamp: $CACHE_TIMESTAMP"
    else
      log "using cached usernames list (age: ${CACHE_AGE}s)"
    fi
    
    # check if filename contains any username
    # use a temporary file to store the result to avoid pipe subshell issues
    TEMP_RESULT=$(mktemp)
    echo "0" > "$TEMP_RESULT"
    
    echo "$CACHED_USERNAMES" | while read -r USERNAME; do
      if [ -z "$USERNAME" ]; then
        continue
      fi
      
      if echo "$FILENAME" | grep -q "_${USERNAME}[.][^.]*$"; then
        log "file $FILENAME contains username $USERNAME"
        echo "1" > "$TEMP_RESULT"
        break
      fi
    done
    
    FOUND=$(cat "$TEMP_RESULT")
    rm "$TEMP_RESULT"
    
    if [ "$FOUND" -eq 1 ]; then
      return 0
    else
      log "file $FILENAME does not contain any username"
      return 1
    fi
  }

  # Function to protect important system files
  protect_system_files() {
    log "Protecting system files..."
    
    # Protect welcome file
    if [ -f "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt" ]; then
      chmod 444 "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
      log "Protected welcome file"
    else
      # Recreate if missing
      log "Welcome file missing, recreating it"
      echo "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE" > /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 12 days, and then receive constructive criticism from fellow peers on their track." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "how it works:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "1. upload samples during the sample submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "2. download the sample pack when it becomes available" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "3. create your track using only the provided samples" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "4. upload your finished track during the song submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "5. download and listen to everyone's tracks when the challenge is complete" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "all previous quixit challenges are available in read-only mode." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "if you enjoy quixit, please consider supporting the project with a donation:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      echo "https://www.paypal.com/donate/?hosted_button_id=T73SWSVDGBFH8" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
      chmod 444 "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
    fi
    
    # Update current quixit number file using the locking mechanism
    update_current_quixit_number
    
    # Find and protect files in quixit folders
    find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
      if [ -d "$QUIXIT_DIR" ]; then
        QUIXIT_NUM=$(basename "$QUIXIT_DIR" | cut -d"-" -f2)
        log "Protecting files in quixit-$QUIXIT_NUM"
        
        # Protect phase indicator files
        find "$QUIXIT_DIR" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | while read -r FILE; do
          # Check if file is empty or has been tampered with
          if [ ! -s "$FILE" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" "$FILE"; then
            log "Sample phase file is empty or has been tampered with, restoring content: $FILE"
            DEADLINE=$(basename "$FILE" | sed 's/QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_//')
            echo "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" > "$FILE"
            echo "" >> "$FILE"
            echo "Upload your samples before: $DEADLINE" >> "$FILE"
            echo "" >> "$FILE"
            echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FILE"
            echo "" >> "$FILE"
            echo "Guidelines:" >> "$FILE"
            echo "- Upload audio samples to the 'samples' directory" >> "$FILE"
            echo "- Keep samples to a max size of 20mb each, no larger" >> "$FILE"
            echo "- No more than 5 samples per user" >> "$FILE"
            echo "" >> "$FILE"
            echo "After the deadline, all samples will be compiled into a sample pack for the song phase." >> "$FILE"
          fi
          chmod 444 "$FILE"
          log "Protected samples phase file: $FILE"
        done
        
        find "$QUIXIT_DIR" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | while read -r FILE; do
          # Check if file is empty or has been tampered with
          if [ ! -s "$FILE" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" "$FILE"; then
            log "Song phase file is empty or has been tampered with, restoring content: $FILE"
            DEADLINE=$(basename "$FILE" | sed 's/SUBMIT_SONGS_BEFORE_//')
            echo "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" > "$FILE"
            echo "" >> "$FILE"
            echo "Upload your finished track before: $DEADLINE" >> "$FILE"
            echo "" >> "$FILE"
            echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FILE"
            echo "" >> "$FILE"
            echo "Guidelines:" >> "$FILE"
            echo "- Upload your finished track to the 'songs' directory" >> "$FILE"
            echo "- Use ONLY samples from the provided sample pack" >> "$FILE"
            echo "- important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "$FILE"
            echo "" >> "$FILE"
            echo "After the deadline, all tracks will be compiled into a downloadable archive." >> "$FILE"
          fi
          chmod 444 "$FILE"
          log "Protected songs phase file: $FILE"
        done
        
        # Protect completion indicator
        if [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ]; then
          # Check if file is empty or has been tampered with
          if [ ! -s "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - COMPLETED" "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"; then
            log "Completion file is empty or has been tampered with, restoring content"
            COMPLETION_DATE=$(date +"%Y-%m-%d")
            echo "QUIXIT #$QUIXIT_NUM - COMPLETED" > "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "This quixit challenge is now complete!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "Completed on: $COMPLETION_DATE" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "You can download:" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "- SAMPLE_PACK.tar.gz - All samples used in this challenge" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "- ALL_SONGS.tar.gz - All submitted tracks" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            echo "Thank you for participating!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
          fi
          chmod 444 "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
          log "Protected completion indicator"
        fi
        
        # Protect archive files
        if [ -f "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ]; then
          chmod 444 "$QUIXIT_DIR/SAMPLE_PACK.tar.gz"
          log "Protected sample pack archive"
        fi
        
        if [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ]; then
          chmod 444 "$QUIXIT_DIR/ALL_SONGS.tar.gz"
          log "Protected songs archive"
        fi
        
        # Set permissions on upload directories
        if [ -d "$QUIXIT_DIR/samples" ]; then
          chmod 777 "$QUIXIT_DIR/samples"
          log "Set samples directory to writable"
        fi
        
        if [ -d "$QUIXIT_DIR/songs" ]; then
          chmod 777 "$QUIXIT_DIR/songs"
          log "Set songs directory to writable"
        fi
      fi
    done
  }

  # Function to check if a file is actually an audio file
  is_audio_content() {
    FILE="$1"
    
    # Check file size
    FILE_SIZE=$(stat -c%s "$FILE" 2>/dev/null || echo "0")
    if [ "$FILE_SIZE" -lt 100 ]; then
      log "File is very small ($FILE_SIZE bytes), might still be uploading"
      return 1
    fi
    
    # Check mime type
    MIME_TYPE=$(file --mime-type -b "$FILE")
    FILE_DESC=$(file "$FILE" | sed "s|$FILE: ||")
    
    # Check if mime type is audio
    if echo "$MIME_TYPE" | grep -q "^audio/"; then
      log "File is audio based on mime type"
      return 0
    fi
    
    # Check if file output contains audio signatures
    if echo "$FILE_DESC" | grep -i -q -E "audio|WAVE|AIFF|FLAC|MP3|Vorbis"; then
      log "File is audio based on file description"
      return 0
    fi
    
    # Reject text files
    if echo "$MIME_TYPE" | grep -q "^text/" || echo "$FILE_DESC" | grep -i -q -E "^(ASCII|UTF-8) text"; then
      log "File has audio extension but is actually text: $MIME_TYPE"
      return 1
    fi
    
    # Reject empty files
    if [ ! -s "$FILE" ]; then
      log "File is completely empty"
      return 1
    fi
    
    # Fallback to extension check
    if has_audio_extension "$FILE"; then
      log "Allowing file with audio extension (mime type: $MIME_TYPE)"
      return 0
    fi
    
    return 1
  }

  # Function to check if a file is in the correct directory based on phase
  check_file() {
    FILE="$1"
    IS_CREATE_EVENT="$2"
    IS_PRIORITY="$3"
    log "Checking file: $FILE"
    
    # Extract quixit folder from path
    QUIXIT_FOLDER=""
    if echo "$FILE" | grep -q "/quixit/quixit-[0-9]"; then
      QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
      log "Quixit folder: $QUIXIT_FOLDER"
      
      # Check if file is in a valid upload directory
      if ! echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/" && ! echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
        log "File not in samples or songs directory, removing file: $FILE"
        rm -f "$FILE"
        return 1
      fi
    else
      # File is not in a quixit folder
      log "File not in a quixit folder, removing file: $FILE"
      rm -f "$FILE"
      return 1
    fi
    
    # Check if file has an allowed audio extension - do this BEFORE any delays
    if ! has_audio_extension "$FILE"; then
      log "File does not have an allowed audio extension, removing file immediately: $FILE"
      rm -f "$FILE"
      return 1
    fi
    
    # Add delay to allow file to finish uploading
    # Use a much shorter delay for priority files in samples/songs directories
    if [ "$IS_PRIORITY" = "true" ]; then
      log "Priority file detected, using minimal delay"
      sleep 0.5
    elif [ "$IS_CREATE_EVENT" = "true" ]; then
      log "Create event detected, using shorter delay"
      sleep 1
    else
      sleep 3
    fi
    
    # Skip if file no longer exists
    if [ ! -f "$FILE" ]; then
      log "File no longer exists, skipping check"
      return 1
    fi
    
    # Check if file is actually an audio file
    if ! is_audio_content "$FILE"; then
      # Add a second chance with a longer delay
      log "File appears empty or not audio, waiting longer for potential large upload..."
      # Use a shorter delay for priority files
      if [ "$IS_PRIORITY" = "true" ]; then
        sleep 1
      elif [ "$IS_CREATE_EVENT" = "true" ]; then
        sleep 3
      else
      sleep 7
      fi
      
      # Check again after longer delay
      if [ ! -f "$FILE" ]; then
        log "File no longer exists after second wait, skipping check"
        return 1
      fi
      
      if ! is_audio_content "$FILE"; then
        log "File does not contain audio content after extended wait, removing file: $FILE"
        rm -f "$FILE"
        return 1
      fi
    fi
    
    # Check for songs phase
    if find "/srv/quixit/$QUIXIT_FOLDER" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | grep -q .; then
      log "Found songs phase indicator file"
      
      # Only allow uploads to songs directory
      if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
        log "Song upload allowed during songs phase"
        
        # check if filename contains a username
        FILENAME=$(basename "$FILE")
        if ! check_username_in_filename "$FILENAME"; then
          log "song file does not contain a username in the filename, removing: $FILE"
          log "filename format should be: track_username.extension (e.g. mysong_quixit-admin.mp3)"
          rm -f "$FILE"
          return 1
        fi
        
        return 0
      else
        log "Not uploading to songs directory during songs phase, removing file: $FILE"
        rm -f "$FILE"
        return 1
      fi
    fi
    
    # Check for samples phase
    if find "/srv/quixit/$QUIXIT_FOLDER" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | grep -q .; then
      log "Found samples phase indicator file"
      
      # Only allow uploads to samples directory
      if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/"; then
        log "Sample upload allowed during samples phase"
        return 0
      else
        log "Not uploading to samples directory during samples phase, removing file: $FILE"
        rm -f "$FILE"
        return 1
      fi
    fi
    
    # Check for completed phase
    if [ -f "/srv/quixit/$QUIXIT_FOLDER/QUIXIT_COMPLETED.txt" ]; then
      log "Found completed phase indicator file"
      log "Quixit is completed, removing uploaded file: $FILE"
      rm -f "$FILE"
      return 1
    fi
    
    # If we got here, the quixit exists but we are not in a valid phase
    log "Not in a valid phase for uploads to this quixit, removing file: $FILE"
    rm -f "$FILE"
    return 1
  }

  # Function to check for unauthorized directories created by users
  check_unauthorized_directories() {
    log "Checking for unauthorized directories..."
    
    # Find all directories in the quixit folder
    find /srv/quixit -type d | while read -r DIR; do
      # Skip the root quixit directory
      if [ "$DIR" = "/srv/quixit" ]; then
        continue
      fi
      
      # Skip quixit-* directories at the root level (these are created by admin)
      if echo "$DIR" | grep -q "^/srv/quixit/quixit-[0-9]" && [ "$(echo "$DIR" | tr -cd '/' | wc -c)" -eq 3 ]; then
        continue
      fi
      
      # Skip samples and songs directories within quixit-* folders
      if echo "$DIR" | grep -q "/quixit-[0-9][0-9]*/samples$" || echo "$DIR" | grep -q "/quixit-[0-9][0-9]*/songs$"; then
        continue
      fi
      
      # If we get here, this is an unauthorized directory
      # Check if it's within samples or songs (user-created subdirectory)
      if echo "$DIR" | grep -q "/samples/" || echo "$DIR" | grep -q "/songs/"; then
        log "Found unauthorized subdirectory in samples/songs: $DIR"
        rm -rf "$DIR"
        log "Removed unauthorized directory: $DIR"
      # Check if it's a user-created directory at the root level
      elif [ "$(echo "$DIR" | tr -cd '/' | wc -c)" -eq 2 ] && ! echo "$DIR" | grep -q "^/srv/quixit/quixit-"; then
        log "Found unauthorized directory at root level: $DIR"
        rm -rf "$DIR"
        log "Removed unauthorized directory: $DIR"
      fi
    done
  }

  # Function to check for phase transitions and clean up files
  check_phase_transitions() {
    log "Checking for phase transitions..."
    
    # Find all quixit folders
    find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
      if [ -d "$QUIXIT_DIR" ]; then
        QUIXIT_NUM=$(basename "$QUIXIT_DIR" | cut -d"-" -f2)
        log "Checking quixit-$QUIXIT_NUM for phase transitions"
        
        # Check for samples phase
        SAMPLE_PHASE_FILE=$(find "$QUIXIT_DIR" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | head -1)
        if [ -n "$SAMPLE_PHASE_FILE" ]; then
          # Ensure samples directory exists
          if [ ! -d "$QUIXIT_DIR/samples" ]; then
            log "Creating samples directory for quixit-$QUIXIT_NUM"
            mkdir -p "$QUIXIT_DIR/samples"
            chmod 777 "$QUIXIT_DIR/samples"
          fi
          
          # Remove songs directory if it exists during samples phase
          if [ -d "$QUIXIT_DIR/songs" ]; then
            log "Removing songs directory during samples phase for quixit-$QUIXIT_NUM"
            rm -rf "$QUIXIT_DIR/songs"
          fi
        fi
        
        # Check for songs phase
        SONG_PHASE_FILE=$(find "$QUIXIT_DIR" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | head -1)
        if [ -n "$SONG_PHASE_FILE" ]; then
          # Ensure songs directory exists
          if [ ! -d "$QUIXIT_DIR/songs" ]; then
            log "Creating songs directory for quixit-$QUIXIT_NUM"
            mkdir -p "$QUIXIT_DIR/songs"
            chmod 777 "$QUIXIT_DIR/songs"
          fi
        fi
        
        # Check if we just transitioned from samples to songs phase
        if [ -f "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ] && [ -n "$SONG_PHASE_FILE" ]; then
          log "Detected transition to songs phase, checking samples folder"
          
          # Verify sample pack exists and is not empty before removing samples
          if [ -s "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ] && [ -d "$QUIXIT_DIR/samples" ]; then
            log "Sample pack exists and is not empty, removing samples directory"
            rm -rf "$QUIXIT_DIR/samples"
            log "Samples directory removed for quixit-$QUIXIT_NUM"
          elif [ ! -s "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ] && [ -d "$QUIXIT_DIR/samples" ]; then
            log "Sample pack is empty or missing, keeping samples directory"
          fi
          
          # Run a full scan of the songs directory to ensure compliance
          log "Running full scan of songs directory after phase transition"
          if [ -d "$QUIXIT_DIR/songs" ]; then
            find "$QUIXIT_DIR/songs" -type f | while read -r SONG_FILE; do
              log "Checking song file after phase transition: $SONG_FILE"
              check_file "$SONG_FILE"
            done
          fi
        fi
        
        # Check if songs have been compressed but directory still exists
        if [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ] && [ -d "$QUIXIT_DIR/songs" ]; then
          # Verify songs archive exists and is not empty before removing songs directory
          if [ -s "$QUIXIT_DIR/ALL_SONGS.tar.gz" ]; then
            log "Songs have been compressed, removing songs directory"
            rm -rf "$QUIXIT_DIR/songs"
            log "Songs directory removed for quixit-$QUIXIT_NUM"
          fi
        fi
        
        # Check if we just finalized the quixit
        if [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ] && [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ]; then
          log "Detected finalized quixit, ensuring clean structure"
          
          # Remove any remaining samples directory
          if [ -d "$QUIXIT_DIR/samples" ]; then
            rm -rf "$QUIXIT_DIR/samples"
            log "Removed samples directory from finalized quixit-$QUIXIT_NUM"
          fi
          
          # Remove any remaining songs directory
          if [ -d "$QUIXIT_DIR/songs" ]; then
            rm -rf "$QUIXIT_DIR/songs"
            log "Removed songs directory from finalized quixit-$QUIXIT_NUM"
          fi
          
          # Remove any unauthorized files in the root of the quixit directory
          find "$QUIXIT_DIR" -maxdepth 1 -type f | while read -r ROOT_FILE; do
            # Skip protected files
            if echo "$ROOT_FILE" | grep -q "QUIXIT_COMPLETED.txt\|SAMPLE_PACK.tar.gz\|ALL_SONGS.tar.gz\|QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE"; then
              continue
            fi
            
            log "Removing unauthorized file from finalized quixit root: $ROOT_FILE"
            rm -f "$ROOT_FILE"
          done
          
          # Make the entire quixit directory read-only
          chmod -R 555 "$QUIXIT_DIR"
          log "Set entire quixit-$QUIXIT_NUM directory to read-only"
          
          # Ensure the archive files are readable
          chmod 444 "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" "$QUIXIT_DIR/ALL_SONGS.tar.gz"
          log "Ensured archive files are readable in quixit-$QUIXIT_NUM"
        fi
      fi
    done
    
    # Update the current quixit number file after phase transitions
    HIGHEST_NUM=$(find /srv/quixit -maxdepth 1 -type d -name "quixit-*" | sed "s|/srv/quixit/quixit-||" | sort -n | tail -1)
    if [ -z "$HIGHEST_NUM" ]; then
      HIGHEST_NUM=0
    fi
    
    # Update current quixit number file using the locking mechanism
    update_current_quixit_number
  }

  # Function to update current quixit number file with locking
  update_current_quixit_number() {
    # Create a lock file to prevent race conditions
    LOCK_FILE="/tmp/quixit_number_update.lock"
    
    # Try to acquire the lock
    if ! mkdir "$LOCK_FILE" 2>/dev/null; then
      log "Another process is updating quixit number files, skipping this update"
      return 1
    fi
    
    # Ensure the lock is released when the function exits
    trap 'rm -rf "$LOCK_FILE"' EXIT
    
    log "Acquired lock for updating quixit number files"
    
    # Get the highest quixit number from directory names
    HIGHEST_NUM=$(find /srv/quixit -maxdepth 1 -type d -name "quixit-*" | sed "s|/srv/quixit/quixit-||" | sort -n | tail -1)
    if [ -z "$HIGHEST_NUM" ]; then
      HIGHEST_NUM=0
    fi
    
    # Keep only the lowercase file
    echo "$HIGHEST_NUM" > "/srv/quixit/current_quixit_number.txt"
    chmod 444 "/srv/quixit/current_quixit_number.txt"
    
    log "Successfully updated current_quixit_number.txt to $HIGHEST_NUM"
    
    # Release the lock
    rm -rf "$LOCK_FILE"
    trap - EXIT
    
    return 0
  }

  # Run initial phase transition check
  check_phase_transitions

  # Protect system files initially
  protect_system_files

  # Check for unauthorized directories initially
  check_unauthorized_directories

  # Clean up any redundant info files that might exist
  find /srv/quixit -type f -name "QUIXIT_*_SONG_PHASE_INFO.txt" -delete
  find /srv/quixit -type f -name "QUIXIT_*_SAMPLE_PHASE_INFO.txt" -delete
  log "Cleaned up any redundant info files"

  # Run an initial scan of all files to catch any that were added while the watcher was not running
  log "Running initial scan of all files"
  find /srv/quixit -type f | while read -r FILE; do
    # skip system and protected files
    if echo "$FILE" | grep -q "QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE\|QUIXIT_COMPLETED\|SAMPLE_PACK\.tar\.gz\|ALL_SONGS\.tar.gz\|WELCOME_TO_QUIXIT\|current_quixit_number.txt"; then
      continue
    fi
    
    # check if this is a file in a quixit folder
    if echo "$FILE" | grep -q "/quixit/quixit-[0-9]"; then
      QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
      
      # check if file is in samples or songs directory
      if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/" || echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
        log "Checking existing file during initial scan: $FILE"
        check_file "$FILE"
      fi
    fi
  done
  log "Initial file scan complete"

  # Set up a background job to check for phase transitions every 5 minutes
  (
    while true; do
      sleep 300
      check_phase_transitions
      protect_system_files
      check_unauthorized_directories
      
      # scan all existing files to ensure they comply with rules
      log "performing full scan of all files to ensure compliance with rules"
      find /srv/quixit -type f | while read -r FILE; do
        # skip system and protected files
        if echo "$FILE" | grep -q "QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE\|QUIXIT_COMPLETED\|SAMPLE_PACK\.tar\.gz\|ALL_SONGS\.tar.gz\|WELCOME_TO_QUIXIT\|current_quixit_number.txt"; then
          continue
        fi
        
        # check if this is a file in a quixit folder
        if echo "$FILE" | grep -q "/quixit/quixit-[0-9]"; then
          QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
          
          # check if file is in samples or songs directory
          if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/" || echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
            log "scanning existing file: $FILE"
            check_file "$FILE"
          fi
        fi
      done
      
      # Clean up any redundant info files that might exist
      find /srv/quixit -type f -name "QUIXIT_*_SONG_PHASE_INFO.txt" -delete
      find /srv/quixit -type f -name "QUIXIT_*_SAMPLE_PHASE_INFO.txt" -delete
      log "cleaned up any redundant info files in background job"
    done
  ) &
  BACKGROUND_PID=$!
  log "Started background job with PID: $BACKGROUND_PID"

  # Set up a continuous scanner that checks for invalid files every 1 second
  (
  while true; do
      # Find all samples and songs directories
      find /srv/quixit -type d | grep -E '/(samples|songs)$' | while read -r DIR; do
        # Check for invalid files in this directory
        find "$DIR" -type f -not -path "*/\.*" | while read -r FILE; do
          # Skip if file was recently processed
          FILE_HASH=$(echo "$FILE" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          
          if [ -f "$MARKER_FILE" ]; then
            MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
            if [ "$MARKER_AGE" -lt 5 ]; then  # Reduced from 10 to 5 seconds
              continue
            fi
          fi
          
          # Check for invalid extensions immediately
          if ! echo "$FILE" | grep -q -i -E '\.wav$|\.mp3$|\.ogg$|\.flac$|\.aiff$'; then
            log "Continuous scanner: Removing file with invalid extension: $FILE"
            rm -f "$FILE"
            touch "$MARKER_FILE"
            continue
          fi
          
          # If in songs directory, check for username in filename
          if echo "$FILE" | grep -q "/songs/"; then
            QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
            # Check if we're in songs phase
            if find "/srv/quixit/$QUIXIT_FOLDER" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | grep -q .; then
              FILENAME=$(basename "$FILE")
              
              # More aggressive check for username pattern
              if ! echo "$FILENAME" | grep -q "_[a-zA-Z0-9-]\+[.][^.]*$"; then
                log "Continuous scanner: Song file does not contain a username in the filename, removing: $FILE"
                rm -f "$FILE"
                touch "$MARKER_FILE"
                continue
              fi
              
              # Additional check for known usernames without API call
              # This is a more aggressive approach that doesn't wait for the API check
              if ! echo "$FILENAME" | grep -q -E "_(quixit-admin|zfigz|admin)[.][^.]*$"; then
                # Check if the file has been around for more than 5 seconds
                FILE_AGE=$(($(date +%s) - $(date -r "$FILE" +%s)))
                if [ "$FILE_AGE" -gt 5 ]; then
                  log "Continuous scanner: Song file does not contain a known username after 5 seconds, removing: $FILE"
                  rm -f "$FILE"
                  touch "$MARKER_FILE"
                fi
              fi
            fi
          fi
        done
      done
      
      # Check for files in the root of finalized quixit directories
      find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
        # Check if this quixit is finalized
        if [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ] && [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ]; then
          # Find files in the root of the quixit directory
          find "$QUIXIT_DIR" -maxdepth 1 -type f | while read -r ROOT_FILE; do
            # Skip if file was recently processed
            FILE_HASH=$(echo "$ROOT_FILE" | md5sum | cut -d' ' -f1)
            MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
            
            if [ -f "$MARKER_FILE" ]; then
              MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
              if [ "$MARKER_AGE" -lt 5 ]; then
                continue
              fi
            fi
            
            # Skip protected files
            if echo "$ROOT_FILE" | grep -q "QUIXIT_COMPLETED.txt\|SAMPLE_PACK.tar.gz\|ALL_SONGS.tar.gz\|QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE"; then
              continue
            fi
            
            log "Continuous scanner: Removing unauthorized file from finalized quixit root: $ROOT_FILE"
            rm -f "$ROOT_FILE"
            touch "$MARKER_FILE"
          done
        fi
      done
      
      # Check for protected files in unauthorized locations
      find /srv/quixit -type f | grep -E "QUIXIT_HAS_BEGUN|SUBMIT_SONGS_BEFORE|QUIXIT_COMPLETED|SAMPLE_PACK\.tar\.gz|ALL_SONGS\.tar\.gz" | while read -r PROTECTED_FILE; do
        # Skip if file was recently processed
        FILE_HASH=$(echo "$PROTECTED_FILE" | md5sum | cut -d' ' -f1)
        MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
        
        if [ -f "$MARKER_FILE" ]; then
          MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
          if [ "$MARKER_AGE" -lt 5 ]; then
            continue
          fi
        fi
        
        # Check if this is in a valid location
        if echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_HAS_BEGUN" || \
           echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SUBMIT_SONGS_BEFORE" || \
           echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_COMPLETED" || \
           echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SAMPLE_PACK\.tar\.gz" || \
           echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/ALL_SONGS\.tar\.gz"; then
          
          # This is in the right place, ensure it has the correct permissions
          chmod 444 "$PROTECTED_FILE"
        else
          # This is not in the right place, so remove it
          log "Continuous scanner: Removing protected file in unauthorized location: $PROTECTED_FILE"
          rm -f "$PROTECTED_FILE"
          touch "$MARKER_FILE"
        fi
      done
      
      # Check welcome file
      if [ -f "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt" ]; then
        # Skip if file was recently processed
        FILE_HASH=$(echo "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt" | md5sum | cut -d' ' -f1)
        MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
        
        if [ -f "$MARKER_FILE" ]; then
          MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
          if [ "$MARKER_AGE" -lt 5 ]; then
            continue
          fi
        fi
        
        # Check if content has been modified
        if ! grep -q "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE" "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"; then
          log "Continuous scanner: Welcome file content has been modified, restoring original content"
          echo "WELCOME TO QUIXIT MUSIC COLLABORATION CHALLENGE" > "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 12 days, and then receive constructive criticism from fellow peers on their track." >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "how it works:" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "1. upload samples during the sample submission phase" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "2. download the sample pack when it becomes available" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "3. create your track using only the provided samples" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "4. upload your finished track during the song submission phase" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "5. download and listen to everyone's tracks when the challenge is complete" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "all previous quixit challenges are available in read-only mode." >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "if you enjoy quixit, please consider supporting the project with a donation:" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          echo "https://www.paypal.com/donate/?hosted_button_id=T73SWSVDGBFH8" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
        fi
        
        # Ensure permissions are set
        chmod 444 "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
        touch "$MARKER_FILE"
      fi
      
      # Check current_quixit_number.txt
      if [ -f "/srv/quixit/current_quixit_number.txt" ]; then
        # Skip if file was recently processed
        FILE_HASH=$(echo "/srv/quixit/current_quixit_number.txt" | md5sum | cut -d' ' -f1)
        MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
        
        if [ -f "$MARKER_FILE" ]; then
          MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
          if [ "$MARKER_AGE" -lt 5 ]; then
            continue
          fi
        fi
        
        # Update the current quixit number file using the locking mechanism
        update_current_quixit_number
        touch "$MARKER_FILE"
      fi
      
      # Explicitly check all protected files in all quixit directories
      find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
        QUIXIT_NUM=$(basename "$QUIXIT_DIR" | cut -d"-" -f2)
        
        # Check QUIXIT_COMPLETED.txt
        if [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ]; then
          FILE_HASH=$(echo "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          
          if [ -f "$MARKER_FILE" ]; then
            MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
            if [ "$MARKER_AGE" -ge 5 ]; then
              log "Continuous scanner: Checking QUIXIT_COMPLETED.txt in $QUIXIT_DIR"
              if [ ! -s "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - COMPLETED" "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"; then
                log "Continuous scanner: QUIXIT_COMPLETED.txt content has been modified, restoring content"
                COMPLETION_DATE=$(date +"%Y-%m-%d")
                echo "QUIXIT #$QUIXIT_NUM - COMPLETED" > "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "This quixit challenge is now complete!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "Completed on: $COMPLETION_DATE" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "You can download:" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "- SAMPLE_PACK.tar.gz - All samples used in this challenge" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "- ALL_SONGS.tar.gz - All submitted tracks" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                echo "Thank you for participating!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              fi
              chmod 444 "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              touch "$MARKER_FILE"
            fi
          else
            log "Continuous scanner: First check of QUIXIT_COMPLETED.txt in $QUIXIT_DIR"
            chmod 444 "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            touch "$MARKER_FILE"
          fi
        fi
        
        # Check SUBMIT_SAMPLES_BEFORE_* files
        find "$QUIXIT_DIR" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | while read -r SAMPLE_FILE; do
          FILE_HASH=$(echo "$SAMPLE_FILE" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          
          if [ -f "$MARKER_FILE" ]; then
            MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
            if [ "$MARKER_AGE" -ge 5 ]; then
              log "Continuous scanner: Checking sample phase file in $QUIXIT_DIR"
              if [ ! -s "$SAMPLE_FILE" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" "$SAMPLE_FILE"; then
                log "Continuous scanner: Sample phase file content has been modified, restoring content"
                DEADLINE=$(basename "$SAMPLE_FILE" | sed 's/QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_//')
                echo "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" > "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "Upload your samples before: $DEADLINE" >> "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "Guidelines:" >> "$SAMPLE_FILE"
                echo "- Upload audio samples to the 'samples' directory" >> "$SAMPLE_FILE"
                echo "- Keep samples to a max size of 20mb each, no larger" >> "$SAMPLE_FILE"
                echo "- No more than 5 samples per user" >> "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "After the deadline, all samples will be compiled into a sample pack for the song phase." >> "$SAMPLE_FILE"
              fi
              chmod 444 "$SAMPLE_FILE"
              touch "$MARKER_FILE"
            fi
          else
            log "Continuous scanner: First check of sample phase file in $QUIXIT_DIR"
            chmod 444 "$SAMPLE_FILE"
            touch "$MARKER_FILE"
          fi
        done
        
        # Check SUBMIT_SONGS_BEFORE_* files
        find "$QUIXIT_DIR" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | while read -r SONG_FILE; do
          FILE_HASH=$(echo "$SONG_FILE" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          
          if [ -f "$MARKER_FILE" ]; then
            MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
            if [ "$MARKER_AGE" -ge 5 ]; then
              log "Continuous scanner: Checking song phase file in $QUIXIT_DIR"
              if [ ! -s "$SONG_FILE" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" "$SONG_FILE"; then
                log "Continuous scanner: Song phase file content has been modified, restoring content"
                DEADLINE=$(basename "$SONG_FILE" | sed 's/SUBMIT_SONGS_BEFORE_//')
                echo "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" > "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "Upload your finished track before: $DEADLINE" >> "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "Guidelines:" >> "$SONG_FILE"
                echo "- Upload your finished track to the 'songs' directory" >> "$SONG_FILE"
                echo "- Use ONLY samples from the provided sample pack" >> "$SONG_FILE"
                echo "- important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "After the deadline, all tracks will be compiled into a downloadable archive." >> "$SONG_FILE"
              fi
              chmod 444 "$SONG_FILE"
              touch "$MARKER_FILE"
            fi
          else
            log "Continuous scanner: First check of song phase file in $QUIXIT_DIR"
            chmod 444 "$SONG_FILE"
            touch "$MARKER_FILE"
          fi
        done
      done
      
      # Sleep for a short time before next scan
      sleep 1  # Reduced from 2 to 1 second
    done
  ) &
  CONTINUOUS_SCANNER_PID=$!
  log "Started continuous scanner with PID: $CONTINUOUS_SCANNER_PID"

  # Update the trap to kill both background processes
  trap 'kill $BACKGROUND_PID $CONTINUOUS_SCANNER_PID 2>/dev/null; log "Killed background jobs"; exit' INT TERM EXIT

  # main loop that restarts inotifywait if it exits
  log "Starting main file watch loop"
  while true; do
    log "Setting up inotifywait to monitor file events"
    # Use inotifywait with -m flag to keep it running continuously
    inotifywait -m -r -e close_write,moved_to,modify,attrib,create /srv/quixit 2>/dev/null | while read -r DIR EVENT FILE; do
      FULL_PATH="${DIR}${FILE}"
      log "Event: $EVENT, file: $FULL_PATH"
      
      # Skip if this file was recently processed
      if was_recently_processed "$FULL_PATH"; then
        continue
      fi
      
      # Check if this is a directory creation event
      if [ -d "$FULL_PATH" ] && echo "$EVENT" | grep -q "CREATE"; then
        log "Directory created: $FULL_PATH"
        
        # Check if this is an allowed directory
        if echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*$" || \
           echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/samples$" || \
           echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/songs$"; then
          # This is an allowed directory structure, likely created by admin
          log "Allowed directory structure detected, keeping directory"
        else
          # This is an unauthorized directory created by a user
          log "Unauthorized directory created, removing: $FULL_PATH"
          rm -rf "$FULL_PATH"
        fi
        continue
      fi
      
      # Skip directories and temporary files for regular file checks
      if [ -d "$FULL_PATH" ] || echo "$FILE" | grep -q "\.tmp$"; then
        log "Skipping directory or temporary file"
        continue
      fi
      
      # Immediate check for invalid file extensions in samples/songs directories
      if echo "$EVENT" | grep -q "CREATE" && (echo "$FULL_PATH" | grep -q "/samples/" || echo "$FULL_PATH" | grep -q "/songs/"); then
        # Check file extension immediately without any delay
        if ! echo "$FULL_PATH" | grep -q -i -E '\.wav$|\.mp3$|\.ogg$|\.flac$|\.aiff$'; then
          log "Immediate deletion: File with invalid extension detected in samples/songs directory: $FULL_PATH"
          rm -f "$FULL_PATH"
          # Mark as processed to avoid duplicate processing
          FILE_HASH=$(echo "$FULL_PATH" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          touch "$MARKER_FILE"
          continue
        fi
      fi
      
      # Check if this is a system file that was modified
      if echo "$EVENT" | grep -q "MODIFY\|ATTRIB"; then
        # Check if it is a protected file
        if echo "$FULL_PATH" | grep -q "QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE\|QUIXIT_COMPLETED\|SAMPLE_PACK\.tar\.gz\|ALL_SONGS\.tar.gz\|WELCOME_TO_QUIXIT"; then
          log "Detected modification to protected file: $FULL_PATH, restoring permissions"
          chmod 444 "$FULL_PATH"
          
          # Special handling for welcome file
          if echo "$FULL_PATH" | grep -q "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"; then
            log "Detected modification to welcome file, checking content"
            if ! grep -q "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE" "$FULL_PATH"; then
              log "Welcome file content has been modified, restoring original content"
              echo "WELCOME TO QUIXIT MUSIC COLLABORATION CHALLENGE" > "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 12 days, and then receive constructive criticism from fellow peers on their track." >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "how it works:" >> "$FULL_PATH"
              echo "1. upload samples during the sample submission phase" >> "$FULL_PATH"
              echo "2. download the sample pack when it becomes available" >> "$FULL_PATH"
              echo "3. create your track using only the provided samples" >> "$FULL_PATH"
              echo "4. upload your finished track during the song submission phase" >> "$FULL_PATH"
              echo "5. download and listen to everyone's tracks when the challenge is complete" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "all previous quixit challenges are available in read-only mode." >> "$FULL_PATH"
              chmod 444 "$FULL_PATH"
            fi
            continue
          fi
          
          # Special handling for QUIXIT_HAS_BEGUN files
          if echo "$FULL_PATH" | grep -q "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_"; then
            log "Detected modification to sample phase file, checking content"
            QUIXIT_NUM=$(basename "$(dirname "$FULL_PATH")" | cut -d"-" -f2)
            if [ ! -s "$FULL_PATH" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" "$FULL_PATH"; then
              log "Sample phase file content has been modified, restoring content"
              DEADLINE=$(basename "$FULL_PATH" | sed 's/QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" > "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Upload your samples before: $DEADLINE" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Guidelines:" >> "$FULL_PATH"
              echo "- Upload audio samples to the 'samples' directory" >> "$FULL_PATH"
              echo "- Keep samples to a max size of 20mb each, no larger" >> "$FULL_PATH"
              echo "- No more than 5 samples per user" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "After the deadline, all samples will be compiled into a sample pack for the song phase." >> "$FULL_PATH"
              chmod 444 "$FULL_PATH"
            fi
            continue
          fi
          
          # Special handling for SUBMIT_SONGS_BEFORE files
          if echo "$FULL_PATH" | grep -q "SUBMIT_SONGS_BEFORE_"; then
            log "Detected modification to song phase file, checking content"
            QUIXIT_NUM=$(basename "$(dirname "$FULL_PATH")" | cut -d"-" -f2)
            if [ ! -s "$FULL_PATH" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" "$FULL_PATH"; then
              log "Song phase file content has been modified, restoring content"
              DEADLINE=$(basename "$FULL_PATH" | sed 's/SUBMIT_SONGS_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" > "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Upload your finished track before: $DEADLINE" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Guidelines:" >> "$FULL_PATH"
              echo "- Upload your finished track to the 'songs' directory" >> "$FULL_PATH"
              echo "- Use ONLY samples from the provided sample pack" >> "$FULL_PATH"
              echo "- important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "After the deadline, all tracks will be compiled into a downloadable archive." >> "$FULL_PATH"
              chmod 444 "$FULL_PATH"
            fi
            continue
          fi
          
          # Special handling for QUIXIT_COMPLETED.txt
          if echo "$FULL_PATH" | grep -q "QUIXIT_COMPLETED.txt"; then
            log "Detected modification to completion file, checking content"
            QUIXIT_NUM=$(basename "$(dirname "$FULL_PATH")" | cut -d"-" -f2)
            if [ ! -s "$FULL_PATH" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - COMPLETED" "$FULL_PATH"; then
              log "Completion file content has been modified, restoring content"
              COMPLETION_DATE=$(date +"%Y-%m-%d")
              echo "QUIXIT #$QUIXIT_NUM - COMPLETED" > "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "This quixit challenge is now complete!" >> "$FULL_PATH"
              echo "Completed on: $COMPLETION_DATE" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "You can download:" >> "$FULL_PATH"
              echo "- SAMPLE_PACK.tar.gz - All samples used in this challenge" >> "$FULL_PATH"
              echo "- ALL_SONGS.tar.gz - All submitted tracks" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Thank you for participating!" >> "$FULL_PATH"
              chmod 444 "$FULL_PATH"
            fi
            continue
          fi
          continue
        fi
        
        # Special handling for current_quixit_number.txt
        if echo "$FULL_PATH" | grep -q "current_quixit_number.txt"; then
          log "Detected modification to quixit number file, restoring content and permissions"
          
          # Use the locking mechanism to update the quixit number file
          update_current_quixit_number
          continue
        fi
      fi
      
      # For new files, check if they are allowed
      if echo "$EVENT" | grep -q "CLOSE_WRITE\|MOVED_TO\|CREATE"; then
        # Prioritize CREATE events for faster response
        IS_CREATE_EVENT="false"
        IS_PRIORITY="false"
        
        if echo "$EVENT" | grep -q "CREATE"; then
          IS_CREATE_EVENT="true"
          log "Prioritizing CREATE event for faster response"
        fi
        
        # Check if this is a protected file name that was created by a user
        if echo "$FILE" | grep -q -E "QUIXIT_HAS_BEGUN|SUBMIT_SONGS_BEFORE|QUIXIT_COMPLETED|SAMPLE_PACK\.tar\.gz|ALL_SONGS\.tar\.gz"; then
          # Extract quixit folder if applicable
          QUIXIT_FOLDER=""
          if echo "$FULL_PATH" | grep -q "/quixit/quixit-[0-9]"; then
            QUIXIT_FOLDER=$(echo "$FULL_PATH" | grep -o "quixit-[0-9][0-9]*")
            log "Detected creation of protected file name in $QUIXIT_FOLDER: $FULL_PATH"
            
            # Check if this is an admin-created file (we can't really tell, but we can check if it's in the right place)
            if echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_HAS_BEGUN" || \
               echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SUBMIT_SONGS_BEFORE" || \
               echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_COMPLETED" || \
               echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SAMPLE_PACK\.tar\.gz" || \
               echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/ALL_SONGS\.tar\.gz"; then
              
              # This is in the right place, so it might be legitimate
              # Set proper permissions and trigger phase transition check
              log "Setting proper permissions for protected file: $FULL_PATH"
              chmod 444 "$FULL_PATH"
              
              # Trigger phase transition check to handle the new file
              check_phase_transitions
            else
              # This is not in the right place, so remove it
              log "Removing unauthorized protected file name: $FULL_PATH"
              rm -f "$FULL_PATH"
            fi
            continue
          fi
        fi
        
        # Check if this is a file in the root of a finalized quixit directory
        if echo "$FULL_PATH" | grep -q "/quixit/quixit-[0-9][0-9]*/" && ! echo "$FULL_PATH" | grep -q "/samples/" && ! echo "$FULL_PATH" | grep -q "/songs/"; then
          QUIXIT_FOLDER=$(echo "$FULL_PATH" | grep -o "quixit-[0-9][0-9]*")
          
          # Check if this quixit is finalized
          if [ -f "/srv/quixit/$QUIXIT_FOLDER/QUIXIT_COMPLETED.txt" ] && [ -f "/srv/quixit/$QUIXIT_FOLDER/ALL_SONGS.tar.gz" ]; then
            # Skip protected files
            if ! echo "$FULL_PATH" | grep -q "QUIXIT_COMPLETED.txt\|SAMPLE_PACK.tar.gz\|ALL_SONGS.tar.gz\|QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE"; then
              log "File uploaded to root of finalized quixit directory, removing: $FULL_PATH"
              rm -f "$FULL_PATH"
              continue
            fi
          fi
        fi
        
        # Give highest priority to files in samples or songs directories
        if echo "$FULL_PATH" | grep -q "/samples/" || echo "$FULL_PATH" | grep -q "/songs/"; then
          IS_PRIORITY="true"
          log "High priority file in samples/songs directory, processing immediately"
          
          # For highest priority files, process them in a background process to avoid blocking
          # This ensures we can continue processing other events while this file is being checked
          (
            check_file "$FULL_PATH" "$IS_CREATE_EVENT" "$IS_PRIORITY"
          ) &
        else
        # Check if the file is allowed based on phase
          check_file "$FULL_PATH" "$IS_CREATE_EVENT" "$IS_PRIORITY"
        fi
      fi
      
      # Protect system files after file operations
      protect_system_files
    done
    
    # If inotifywait exits, log it and restart after a short delay
    log "inotifywait exited, restarting in 5 seconds..."
    sleep 5
    log "Restarting inotifywait..."
  done
  EOF

    # Make the watcher script executable
    chmod +x /tmp/watcher.sh
    
  # Execute the watcher script with exec to replace the current process
    exec /tmp/watcher.sh

---
apiVersion: apps/v1
kind: Deployment
metadata:
 name: quixit
 namespace: quixit
 labels:
  app: quixit
spec:
 replicas: 1
 revisionHistoryLimit: 3
 strategy:
  type: RollingUpdate
 selector:
  matchLabels:
   app: quixit
 template:
  metadata:
   labels:
    app: quixit
  spec:
   containers:
    - name: quixit
      image: filebrowser/filebrowser:v2.32.0
      imagePullPolicy: IfNotPresent
      env:
       - name: QUIXIT_HOST
         value: 'quixit.us'
       - name: QUIXIT_USER
         valueFrom:
          secretKeyRef:
           name: quixit-admin-credentials
           key: admin-user
       - name: QUIXIT_PW
         valueFrom:
          secretKeyRef:
           name: quixit-admin-credentials
           key: admin-password
      volumeMounts:
       - name: quixit
         mountPath: /srv
         subPath: files
       - name: quixit
         mountPath: /database
         subPath: database
       - name: quixit
         mountPath: /branding
         subPath: branding
       - name: quixit
         mountPath: /logs
         subPath: logs
       - name: quixit-scripts
         mountPath: /scripts
      ports:
       - name: http
         containerPort: 44301
         protocol: TCP
      resources:
       requests:
        cpu: 500m
        memory: 512Mi
       limits:
        memory: 512Mi
      command: ['/bin/sh', '-c', '/scripts/init-quixit.sh']
    - name: file-watcher
      image: alpine/curl:8.12.1
      imagePullPolicy: IfNotPresent
      command: ['/bin/sh', '-c']
      args:
       - |
        cp /scripts/wrapper.sh /tmp/wrapper.sh
        chmod +x /tmp/wrapper.sh
        exec /tmp/wrapper.sh
      env:
       - name: QUIXIT_USER
         valueFrom:
          secretKeyRef:
           name: quixit-admin-credentials
           key: admin-user
       - name: QUIXIT_PW
         valueFrom:
          secretKeyRef:
           name: quixit-admin-credentials
           key: admin-password
      volumeMounts:
       - name: quixit
         mountPath: /srv
         subPath: files
       - name: quixit
         mountPath: /logs
         subPath: logs
       - name: quixit-scripts
         mountPath: /scripts
      resources:
       requests:
        cpu: 100m
        memory: 128Mi
    - name: log-rotator
      image: alpine:3.21.3
      imagePullPolicy: IfNotPresent
      command: ['/bin/sh', '-c']
      args:
       - |
        # install logrotate
        apk add --no-cache logrotate

        # create logrotate config
        cat > /etc/logrotate.d/quixit << EOF
        # use root user and group for rotation regardless of directory permissions
        su root root

        /logs/watcher.log {
          size 10M
          rotate 3
          compress
          missingok
          notifempty
          copytruncate
          dateext
          dateformat -%Y%m%d-%H%M%S
          create 0644 root root
          postrotate
            echo "[$(date)] watcher.log rotated" >> /logs/logrotate.log
          endscript
        }

        /logs/filebrowser.log {
          size 5M
          rotate 2
          compress
          missingok
          notifempty
          copytruncate
          dateext
          dateformat -%Y%m%d-%H%M%S
          create 0644 root root
          postrotate
            echo "[$(date)] filebrowser.log rotated" >> /logs/logrotate.log
          endscript
        }
        EOF

        # create logrotate status file
        touch /var/lib/logrotate/status

        # run logrotate immediately to handle existing large logs
        echo "[$(date)] Initial log rotation to handle existing large logs" >> /logs/logrotate.log
        logrotate -vf /etc/logrotate.d/quixit

        # run logrotate every 15 minutes to be more aggressive with large logs
        while true; do
          sleep 900
          echo "[$(date)] Running scheduled logrotate check" >> /logs/logrotate.log
          logrotate -v /etc/logrotate.d/quixit
        done
      volumeMounts:
       - name: quixit
         mountPath: /logs
         subPath: logs
      resources:
       requests:
        cpu: 50m
        memory: 64Mi
       limits:
        memory: 128Mi
   volumes:
    - name: quixit
      persistentVolumeClaim:
       claimName: quixit
    - name: quixit-scripts
      configMap:
       name: quixit-scripts
       defaultMode: 0755
