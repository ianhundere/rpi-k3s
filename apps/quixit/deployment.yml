apiVersion: v1
kind: ConfigMap
metadata:
  name: quixit-scripts
  namespace: quixit
  labels:
    app: quixit
data:
  init-quixit.sh: |
    #!/usr/bin/env sh

    # Create logs directory
    mkdir -p /logs

    /bin/filebrowser config init --database /database/filebrowser.db

    /bin/filebrowser config set \
        --database /database/filebrowser.db \
        --port 44301 \
        --address 0.0.0.0 \
        --baseurl "/" \
        --root "/srv" \
        --branding.name "${QUIXIT_HOST}" \
        --branding.disableExternal \
        --branding.disableUsedPercentage \
        --branding.files "/branding" \
        --signup \
        --log "/logs/filebrowser.log"

    # create main quixit directory
    mkdir -p /srv/quixit

    # create welcome file
    echo "WELCOME TO QUIXIT MUSIC COLLABORATION CHALLENGE" > /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 14 days, and then receive constructive criticism from fellow peers on their track." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "how it works:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "1. upload samples during the sample submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "2. download the sample pack when it becomes available" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "3. create your track using only the provided samples" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "4. upload your finished track during the song submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "5. download and listen to everyone's tracks when the challenge is complete" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "all previous quixit challenges are available in read-only mode." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "if you enjoy quixit, please consider supporting the project with a donation:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
    echo "https://www.paypal.com/donate/?hosted_button_id=T73SWSVDGBFH8" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt

    # create or update admin user
    /bin/filebrowser users add "${QUIXIT_USER}" "${QUIXIT_PW}" --perm.admin --database /database/filebrowser.db || \
    /bin/filebrowser users update "${QUIXIT_USER}" --password "${QUIXIT_PW}" --database /database/filebrowser.db

    # set default permissions for new users
    /bin/filebrowser config set \
        --database /database/filebrowser.db \
        --scope "/quixit" \
        --perm.admin=false \
        --perm.execute=false \
        --perm.create=true \
        --perm.rename=false \
        --perm.modify=true \
        --perm.delete=false \
        --perm.share=false \
        --perm.download=true

    # start filebrowser
    exec /bin/filebrowser --port 44301 --database /database/filebrowser.db --log "/logs/filebrowser.log"
  wrapper.sh: |
    #!/bin/sh

    # Create logs directory
    mkdir -p /logs

    # Install required tools
    apk add --no-cache inotify-tools util-linux file

    # Create the watcher script
    cat > /tmp/watcher.sh << 'EOF'
    #!/bin/sh

    # Set up logging
    LOG_FILE=/logs/watcher.log

    # basic log size management function
    manage_log_size() {
      # check if log file exists and is larger than 50MB
      if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE") -gt 52428800 ]; then
        echo "[$(date)] log file exceeds 50MB, truncating to last 10MB" > "$LOG_FILE.tmp"
        tail -c 10485760 "$LOG_FILE" >> "$LOG_FILE.tmp"
        mv "$LOG_FILE.tmp" "$LOG_FILE"
        echo "[$(date)] log file truncated" >> "$LOG_FILE"
      fi
    }

    # check log size every 15 minutes in the background
    (
      while true; do
        manage_log_size
        sleep 900
      done
    ) &

    log() {
      echo "[$(date)] $1" | tee -a "$LOG_FILE"
    }

    log "Starting file watcher..."

    # global variables for caching usernames
    CACHED_USERNAMES=""
    CACHE_TIMESTAMP=0
    CACHE_TTL=900  # 15 minutes in seconds

    # Function to update username list from API
    update_username_file() {
      log "updating shared username file"
      
      # Create a marker to indicate we're working on updating the file
      echo "updating" > /logs/username_update.marker
      
      # API endpoint and credentials
      API_HOST="quixit.quixit"
      API_PORT="44301"
      
      # Get auth token
      log "attempting login to API at $API_HOST:$API_PORT"
      AUTH_RESPONSE=$(curl -s -X POST "http://$API_HOST:$API_PORT/api/login" \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"${QUIXIT_USER}\",\"password\":\"${QUIXIT_PW}\"}")
      
      if [ -n "$AUTH_RESPONSE" ]; then
        log "successfully obtained API response"
        
        # Get users list
        log "getting users list from API"
        USERS_RESPONSE=$(curl -s -X GET "http://$API_HOST:$API_PORT/api/users" \
          -H "X-Auth: $AUTH_RESPONSE" \
          -H "Content-Type: application/json")
        
        # Extract usernames
        USERNAMES=$(echo "$USERS_RESPONSE" | grep -o '"username":"[^"]*"' | sed 's/"username":"//g' | sed 's/"//g')
        
        if [ -n "$USERNAMES" ]; then
          log "successfully extracted usernames from API"
          
          # Create username file
          echo "$USERNAMES" > /logs/usernames.txt.new
          
          # Replace existing file
          if [ -s "/logs/usernames.txt.new" ]; then
            mv /logs/usernames.txt.new /logs/usernames.txt
            log "updated usernames.txt with API results"
          else
            log "new usernames file is empty, API returned no users"
          fi
        else
          log "failed to extract usernames from API response"
        fi
      else
        log "failed to get auth token from API"
      fi
      
      # Remove marker file
      rm -f /logs/username_update.marker
    }

    # track recently processed files to avoid duplicate processing
    PROCESSED_FILES_DIR="/tmp/processed_files"
    mkdir -p "$PROCESSED_FILES_DIR"

    # function to check if a file was recently processed
    was_recently_processed() {
      FILE_PATH="$1"
      FILE_HASH=$(echo "$FILE_PATH" | md5sum | cut -d' ' -f1)
      MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
      
      if [ -f "$MARKER_FILE" ]; then
        # check if the marker is less than 30 seconds old
        MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
        if [ "$MARKER_AGE" -lt 30 ]; then
          log "file was processed recently ($MARKER_AGE seconds ago), skipping: $FILE_PATH"
          return 0
        fi
      fi
      
      # mark the file as processed
      touch "$MARKER_FILE"
      
      # clean up old markers (older than 1 minute)
      find "$PROCESSED_FILES_DIR" -type f -mmin +1 -delete 2>/dev/null
      
      return 1
    }

    # Function to check if a file has an allowed audio extension
    has_audio_extension() {
      FILE="$1"
      LOWERCASE_FILE=$(echo "$FILE" | tr '[:upper:]' '[:lower:]')
      
      # explicitly check for allowed extensions
      if echo "$LOWERCASE_FILE" | grep -q -E '\.wav$|\.mp3$|\.ogg$|\.flac$|\.aiff$'; then
        return 0
      fi
      
      # explicitly reject common non-audio extensions
      if echo "$LOWERCASE_FILE" | grep -q -E '\.rar$|\.zip$|\.tar$|\.gz$|\.7z$|\.txt$|\.pdf$|\.doc$|\.docx$|\.jpg$|\.jpeg$|\.png$|\.gif$'; then
        log "file has explicitly rejected extension: $FILE"
        return 1
      fi
      
      # reject any other extensions
      return 1
    }

    # helper function to check if a string contains a username (case-sensitive)
    contains_username() {
      FILENAME="$1"
      USERNAME="$2"
      
      # Skip empty usernames
      if [ -z "$USERNAME" ]; then
        return 1
      fi
      
      # Escape special characters in the username for grep
      ESCAPED_USERNAME=$(echo "$USERNAME" | sed 's/[.[\*^$]/\\&/g')
      
      # Basic grep - look for the username
      if echo "$FILENAME" | grep -q "$ESCAPED_USERNAME"; then
        return 0
      fi
      
      return 1
    }

    # function to check if a filename contains a username
    check_username_in_filename() {
      FILENAME="$1"
      log "checking if filename contains a username: $FILENAME"
      
      # First, check if we have a shared username file and use it
      if [ -f "/logs/usernames.txt" ] && [ -s "/logs/usernames.txt" ]; then
        log "using shared username file"
        
        # Read usernames from file
        while read -r USERNAME; do
          if contains_username "$FILENAME" "$USERNAME"; then
            log "file $FILENAME contains username $USERNAME from shared file"
            return 0
          fi
        done < "/logs/usernames.txt"
        
        log "file $FILENAME does not contain any username from shared file"
      fi
      
      # Fallback to API call if shared file isn't available or no match was found
      # check if we need to refresh the cache
      CURRENT_TIME=$(date +%s)
      CACHE_AGE=$((CURRENT_TIME - CACHE_TIMESTAMP))
      
      if [ -z "$CACHED_USERNAMES" ] || [ "$CACHE_AGE" -gt "$CACHE_TTL" ]; then
        log "username cache expired or empty, refreshing from api"
        
        # get auth token from filebrowser api
        API_URL="http://quixit.quixit:44301/api"
        ADMIN_USER="${QUIXIT_USER}"
        ADMIN_PASS="${QUIXIT_PW}"
        
        log "attempting to connect to api: $API_URL with user: $ADMIN_USER"
        
        # get auth token
        TOKEN_RESPONSE=$(curl -s -X POST "$API_URL/login" \
          -H "Content-Type: application/json" \
          -d "{\"username\":\"$ADMIN_USER\",\"password\":\"$ADMIN_PASS\"}" 2>/dev/null)
        
        # check if token was obtained
        if [ -z "$TOKEN_RESPONSE" ]; then
          log "failed to get auth token"
          return 1
        else
          log "successfully obtained auth token: $TOKEN_RESPONSE"
          
          # get users list
          log "fetching users list from api"
          USERS_JSON=$(curl -s -X GET "$API_URL/users" \
            -H "X-Auth: $TOKEN_RESPONSE" \
            -H "Content-Type: application/json" 2>/dev/null)
          
          # extract usernames
          USERNAMES=$(echo "$USERS_JSON" | grep -o '"username":"[^"]*"' | sed 's/"username":"//g' | sed 's/"//g')
          
          # check if we got any usernames
          if [ -z "$USERNAMES" ]; then
            log "failed to get usernames from api"
            return 1
          else
            log "successfully retrieved usernames from api"
            CACHED_USERNAMES="$USERNAMES"
            log "usernames: $CACHED_USERNAMES"
          fi
        fi
        
        # update cache timestamp
        CACHE_TIMESTAMP=$CURRENT_TIME
        log "updated username cache timestamp: $CACHE_TIMESTAMP"
        
        # Update the shared username file
        update_username_file
      else
        log "using cached usernames list (age: ${CACHE_AGE}s)"
      fi
      
      # check if filename contains any username
      # use a temporary file to store the result to avoid pipe subshell issues
      TEMP_RESULT=$(mktemp)
      echo "0" > "$TEMP_RESULT"
      
      echo "$CACHED_USERNAMES" | while read -r USERNAME; do
        if contains_username "$FILENAME" "$USERNAME"; then
          log "file $FILENAME contains username $USERNAME"
          echo "1" > "$TEMP_RESULT"
          break
        fi
      done
      
      FOUND=$(cat "$TEMP_RESULT")
      rm "$TEMP_RESULT"
      
      if [ "$FOUND" -eq 1 ]; then
        return 0
      else
        log "file $FILENAME does not contain any username"
        return 1
      fi
    }

    # Function to protect important system files
    protect_system_files() {
      log "Protecting system files..."
      
      # Protect welcome file
      if [ -f "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt" ]; then
        chmod 444 "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
        log "Protected welcome file"
      else
        # Recreate if missing
        log "Welcome file missing, recreating it"
        echo "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE" > /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 14 days, and then receive constructive criticism from fellow peers on their track." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "how it works:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "1. upload samples during the sample submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "2. download the sample pack when it becomes available" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "3. create your track using only the provided samples" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "4. upload your finished track during the song submission phase" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "5. download and listen to everyone's tracks when the challenge is complete" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "all previous quixit challenges are available in read-only mode." >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "if you enjoy quixit, please consider supporting the project with a donation:" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        echo "https://www.paypal.com/donate/?hosted_button_id=T73SWSVDGBFH8" >> /srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt
        chmod 444 "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
      fi
      
      # Update current quixit number file using the locking mechanism
      update_current_quixit_number
      
      # Find and protect files in quixit folders
      find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
        if [ -d "$QUIXIT_DIR" ]; then
          QUIXIT_NUM=$(basename "$QUIXIT_DIR" | cut -d"-" -f2)
          log "Protecting files in quixit-$QUIXIT_NUM"
          
          # Protect phase indicator files
          find "$QUIXIT_DIR" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | while read -r FILE; do
            # Check if file is empty or has been tampered with
            if [ ! -s "$FILE" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" "$FILE"; then
              log "Sample phase file is empty or has been tampered with, restoring content: $FILE"
              DEADLINE=$(basename "$FILE" | sed 's/QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" > "$FILE"
              echo "" >> "$FILE"
              echo "Upload your samples before: $DEADLINE" >> "$FILE"
              echo "" >> "$FILE"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FILE"
              echo "" >> "$FILE"
              echo "Guidelines:" >> "$FILE"
              echo "- Upload audio samples to the 'samples' directory" >> "$FILE"
              echo "- Keep samples to a max size of 20mb each, no larger" >> "$FILE"
              echo "- No more than 5 samples per user" >> "$FILE"
              echo "" >> "$FILE"
              echo "After the deadline, all samples will be compiled into a sample pack for the song phase." >> "$FILE"
            fi
            chmod 444 "$FILE"
            log "Protected samples phase file: $FILE"
          done
          
          find "$QUIXIT_DIR" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | while read -r FILE; do
            # Check if file is empty or has been tampered with
            if [ ! -s "$FILE" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" "$FILE"; then
              log "Song phase file is empty or has been tampered with, restoring content: $FILE"
              DEADLINE=$(basename "$FILE" | sed 's/SUBMIT_SONGS_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" > "$FILE"
              echo "" >> "$FILE"
              echo "Upload your finished track before: $DEADLINE" >> "$FILE"
              echo "" >> "$FILE"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FILE"
              echo "" >> "$FILE"
              echo "Guidelines:" >> "$FILE"
              echo "- Upload your finished track to the 'songs' directory" >> "$FILE"
              echo "- Use ONLY samples from the provided sample pack" >> "$FILE"
              echo "- Bonus: Use ALL samples from the provided sample pack" >> "$FILE"
              echo "" >> "$FILE"
              echo "- IMPORTANT: When uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "$FILE"
              echo "" >> "$FILE"
              echo "After the deadline, all tracks will be compiled into a downloadable archive." >> "$FILE"
            fi
            chmod 444 "$FILE"
            log "Protected songs phase file: $FILE"
          done
          
          # Protect completion indicator
          if [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ]; then
            # Check if file is empty or has been tampered with
            if [ ! -s "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - COMPLETED" "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"; then
              log "Completion file is empty or has been tampered with, restoring content"
              COMPLETION_DATE=$(date +"%Y-%m-%d")
              echo "QUIXIT #$QUIXIT_NUM - COMPLETED" > "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "This quixit challenge is now complete!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "Completed on: $COMPLETION_DATE" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "You can download:" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "- SAMPLE_PACK.tar.gz - All samples used in this challenge" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "- ALL_SONGS.tar.gz - All submitted tracks" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              echo "Thank you for participating!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            fi
            chmod 444 "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
            log "Protected completion indicator"
          fi
          
          # Protect archive files
          if [ -f "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ]; then
            chmod 444 "$QUIXIT_DIR/SAMPLE_PACK.tar.gz"
            log "Protected sample pack archive"
          fi
          
          if [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ]; then
            chmod 444 "$QUIXIT_DIR/ALL_SONGS.tar.gz"
            log "Protected songs archive"
          fi
          
          # Set permissions on upload directories
          if [ -d "$QUIXIT_DIR/samples" ]; then
            chmod 777 "$QUIXIT_DIR/samples"
            log "Set samples directory to writable"
          fi
          
          if [ -d "$QUIXIT_DIR/songs" ]; then
            chmod 777 "$QUIXIT_DIR/songs"
            log "Set songs directory to writable"
          fi
        fi
      done
    }

    # Function to check if a file is actually an audio file
    is_audio_content() {
      FILE="$1"
      
      # Check file size
      FILE_SIZE=$(stat -c%s "$FILE" 2>/dev/null || echo "0")
      if [ "$FILE_SIZE" -lt 100 ]; then
        log "File is very small ($FILE_SIZE bytes), might still be uploading"
        return 1
      fi
      
      # Check if file size is stable (not changing)
      OLD_SIZE=$FILE_SIZE
      sleep 1
      NEW_SIZE=$(stat -c%s "$FILE" 2>/dev/null || echo "0")
      if [ "$OLD_SIZE" != "$NEW_SIZE" ]; then
        log "File size is still changing ($OLD_SIZE -> $NEW_SIZE), waiting for upload to complete"
        return 1
      fi
      
      # Check mime type
      MIME_TYPE=$(file --mime-type -b "$FILE")
      FILE_DESC=$(file "$FILE" | sed "s|$FILE: ||")
      
      # Check if mime type is audio
      if echo "$MIME_TYPE" | grep -q "^audio/"; then
        log "File is audio based on mime type"
        return 0
      fi
      
      # Check if file output contains audio signatures
      if echo "$FILE_DESC" | grep -i -q -E "audio|WAVE|AIFF|FLAC|MP3|Vorbis"; then
        log "File is audio based on file description"
        return 0
      fi
      
      # Reject text files
      if echo "$MIME_TYPE" | grep -q "^text/" || echo "$FILE_DESC" | grep -i -q -E "^(ASCII|UTF-8) text"; then
        log "File has audio extension but is actually text: $MIME_TYPE"
        return 1
      fi
      
      # Reject empty files
      if [ ! -s "$FILE" ]; then
        log "File is completely empty"
        return 1
      fi
      
      # Fallback to extension check
      if has_audio_extension "$FILE"; then
        log "Allowing file with audio extension (mime type: $MIME_TYPE)"
        return 0
      fi
      
      return 1
    }

    # Function to check if a file has completed uploading
    is_upload_complete() {
      FILE="$1"
      MAX_WAIT=30  # Maximum wait time in seconds
      WAIT_INTERVAL=1  # Check interval in seconds
      ELAPSED=0
      
      # Get initial size
      OLD_SIZE=$(stat -c%s "$FILE" 2>/dev/null || echo "0")
      
      while [ "$ELAPSED" -lt "$MAX_WAIT" ]; do
        sleep "$WAIT_INTERVAL"
        ELAPSED=$((ELAPSED + WAIT_INTERVAL))
        
        # Get new size
        NEW_SIZE=$(stat -c%s "$FILE" 2>/dev/null || echo "0")
        
        # If file size hasn't changed in 2 consecutive checks, consider it complete
        if [ "$OLD_SIZE" = "$NEW_SIZE" ]; then
          log "File size stable for $ELAPSED seconds, upload appears complete"
          return 0
        fi
        
        OLD_SIZE=$NEW_SIZE
      done
      
      log "File size still changing after $MAX_WAIT seconds, upload may be incomplete"
      return 1
    }

    # Function to check if a file is in the correct directory based on phase
    check_file() {
      FILE="$1"
      IS_CREATE_EVENT="$2"
      IS_PRIORITY="$3"
      log "Checking file: $FILE"
      
      # Extract quixit folder from path
      QUIXIT_FOLDER=""
      if echo "$FILE" | grep -q "/quixit/quixit-[0-9]"; then
        QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
        log "Quixit folder: $QUIXIT_FOLDER"
        
        # Check if file is in a valid upload directory
        if ! echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/" && ! echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
          log "File not in samples or songs directory, removing file: $FILE"
          rm -f "$FILE"
          return 1
        fi
      else
        # File is not in a quixit folder
        log "File not in a quixit folder, removing file: $FILE"
        rm -f "$FILE"
        return 1
      fi
      
      # Check if file has an allowed audio extension - do this BEFORE any delays
      if ! has_audio_extension "$FILE"; then
        log "File does not have an allowed audio extension, removing file immediately: $FILE"
        rm -f "$FILE"
        return 1
      fi
      
      # Add delay to allow file to finish uploading
      # Use a much shorter delay for priority files in samples/songs directories
      if [ "$IS_PRIORITY" = "true" ]; then
        log "Priority file detected, using minimal delay"
        sleep 0.5
      elif [ "$IS_CREATE_EVENT" = "true" ]; then
        log "Create event detected, using shorter delay"
        sleep 1
      else
        sleep 3
      fi
      
      # Skip if file no longer exists
      if [ ! -f "$FILE" ]; then
        log "File no longer exists, skipping check"
        return 1
      fi
      
      # Wait for upload to complete
      if ! is_upload_complete "$FILE"; then
        log "File upload appears incomplete, skipping check"
        return 1
      fi
      
      # Check if file is actually an audio file
      if ! is_audio_content "$FILE"; then
        # Add a second chance with a longer delay
        log "File appears empty or not audio, waiting longer for potential large upload..."
        # Use a shorter delay for priority files
        if [ "$IS_PRIORITY" = "true" ]; then
          sleep 1
        elif [ "$IS_CREATE_EVENT" = "true" ]; then
          sleep 3
        else
          sleep 7
        fi
        
        # Check again after longer delay
        if [ ! -f "$FILE" ]; then
          log "File no longer exists after second wait, skipping check"
          return 1
        fi
        
        if ! is_upload_complete "$FILE"; then
          log "File upload still appears incomplete after second wait, skipping check"
          return 1
        fi
        
        if ! is_audio_content "$FILE"; then
          log "File does not contain audio content after extended wait, removing file: $FILE"
          rm -f "$FILE"
          return 1
        fi
      fi
      
      # Check for songs phase
      if find "/srv/quixit/$QUIXIT_FOLDER" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | grep -q .; then
        log "Found songs phase indicator file"
        
        # Only allow uploads to songs directory
        if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
          log "Song upload allowed during songs phase"

          return 0
        else
          log "Not uploading to songs directory during songs phase, removing file: $FILE"
          rm -f "$FILE"
          return 1
        fi
      fi
      
      # Check for samples phase
      if find "/srv/quixit/$QUIXIT_FOLDER" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | grep -q .; then
        log "Found samples phase indicator file"
        
        # Only allow uploads to samples directory
        if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/"; then
          log "Sample upload allowed during samples phase"
          return 0
        else
          log "Not uploading to samples directory during samples phase, removing file: $FILE"
          rm -f "$FILE"
          return 1
        fi
      fi
      
      # Check for completed phase
      if [ -f "/srv/quixit/$QUIXIT_FOLDER/QUIXIT_COMPLETED.txt" ]; then
        log "Found completed phase indicator file"
        log "Quixit is completed, removing uploaded file: $FILE"
        rm -f "$FILE"
        return 1
      fi
      
      # If we got here, the quixit exists but we are not in a valid phase
      log "Not in a valid phase for uploads to this quixit, removing file: $FILE"
      rm -f "$FILE"
      return 1
    }

    # Function to check for unauthorized directories created by users
    check_unauthorized_directories() {
      log "Checking for unauthorized directories..."
      
      # Find all directories in the quixit folder
      find /srv/quixit -type d | while read -r DIR; do
        # Skip the root quixit directory
        if [ "$DIR" = "/srv/quixit" ]; then
          continue
        fi
        
        # Skip quixit-* directories at the root level (these are created by admin)
        if echo "$DIR" | grep -q "^/srv/quixit/quixit-[0-9]" && [ "$(echo "$DIR" | tr -cd '/' | wc -c)" -eq 3 ]; then
          continue
        fi
        
        # Skip samples and songs directories within quixit-* folders
        if echo "$DIR" | grep -q "/quixit-[0-9][0-9]*/samples$" || echo "$DIR" | grep -q "/quixit-[0-9][0-9]*/songs$"; then
          continue
        fi
        
        # If we get here, this is an unauthorized directory
        # Check if it's within samples or songs (user-created subdirectory)
        if echo "$DIR" | grep -q "/samples/" || echo "$DIR" | grep -q "/songs/"; then
          log "Found unauthorized subdirectory in samples/songs: $DIR"
          rm -rf "$DIR"
          log "Removed unauthorized directory: $DIR"
        # Check if it's a user-created directory at the root level
        elif [ "$(echo "$DIR" | tr -cd '/' | wc -c)" -eq 2 ] && ! echo "$DIR" | grep -q "^/srv/quixit/quixit-"; then
          log "Found unauthorized directory at root level: $DIR"
          rm -rf "$DIR"
          log "Removed unauthorized directory: $DIR"
        fi
      done
    }

    # Function to check for phase transitions and clean up files
    check_phase_transitions() {
      log "Checking for phase transitions..."
      
      # Find all quixit folders
      find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
        if [ -d "$QUIXIT_DIR" ]; then
          QUIXIT_NUM=$(basename "$QUIXIT_DIR" | cut -d"-" -f2)
          log "Checking quixit-$QUIXIT_NUM for phase transitions"
          
          # Check for samples phase
          SAMPLE_PHASE_FILE=$(find "$QUIXIT_DIR" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | head -1)
          if [ -n "$SAMPLE_PHASE_FILE" ]; then
            # Ensure samples directory exists
            if [ ! -d "$QUIXIT_DIR/samples" ]; then
              log "Creating samples directory for quixit-$QUIXIT_NUM"
              mkdir -p "$QUIXIT_DIR/samples"
              chmod 777 "$QUIXIT_DIR/samples"
            fi
            
            # Remove songs directory if it exists during samples phase
            if [ -d "$QUIXIT_DIR/songs" ]; then
              log "Removing songs directory during samples phase for quixit-$QUIXIT_NUM"
              rm -rf "$QUIXIT_DIR/songs"
            fi
          fi
          
          # Check for songs phase
          SONG_PHASE_FILE=$(find "$QUIXIT_DIR" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | head -1)
          if [ -n "$SONG_PHASE_FILE" ]; then
            # Ensure songs directory exists
            if [ ! -d "$QUIXIT_DIR/songs" ]; then
              log "Creating songs directory for quixit-$QUIXIT_NUM"
              mkdir -p "$QUIXIT_DIR/songs"
              chmod 777 "$QUIXIT_DIR/songs"
            fi
          fi
          
          # Check if we just transitioned from samples to songs phase
          if [ -f "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ] && [ -n "$SONG_PHASE_FILE" ]; then
            log "Detected transition to songs phase, checking samples folder"
            
            # Verify sample pack exists and is not empty before removing samples
            if [ -s "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ] && [ -d "$QUIXIT_DIR/samples" ]; then
              log "Sample pack exists and is not empty, removing samples directory"
              rm -rf "$QUIXIT_DIR/samples"
              log "Samples directory removed for quixit-$QUIXIT_NUM"
            elif [ ! -s "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" ] && [ -d "$QUIXIT_DIR/samples" ]; then
              log "Sample pack is empty or missing, keeping samples directory"
            fi
            
            # Run a full scan of the songs directory to ensure compliance
            log "Running full scan of songs directory after phase transition"
            if [ -d "$QUIXIT_DIR/songs" ]; then
              find "$QUIXIT_DIR/songs" -type f | while read -r SONG_FILE; do
                log "Checking song file after phase transition: $SONG_FILE"
                check_file "$SONG_FILE"
              done
            fi
          fi
          
          # Check if songs have been compressed but directory still exists
          if [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ] && [ -d "$QUIXIT_DIR/songs" ]; then
            # Verify songs archive exists and is not empty before removing songs directory
            if [ -s "$QUIXIT_DIR/ALL_SONGS.tar.gz" ]; then
              log "Songs have been compressed, removing songs directory"
              rm -rf "$QUIXIT_DIR/songs"
              log "Songs directory removed for quixit-$QUIXIT_NUM"
            fi
          fi
          
          # Check if we just finalized the quixit
          if [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ] && [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ]; then
            log "Detected finalized quixit, ensuring clean structure"
            
            # Remove any remaining samples directory
            if [ -d "$QUIXIT_DIR/samples" ]; then
              rm -rf "$QUIXIT_DIR/samples"
              log "Removed samples directory from finalized quixit-$QUIXIT_NUM"
            fi
            
            # Remove any remaining songs directory
            if [ -d "$QUIXIT_DIR/songs" ]; then
              rm -rf "$QUIXIT_DIR/songs"
              log "Removed songs directory from finalized quixit-$QUIXIT_NUM"
            fi
            
            # Remove any unauthorized files in the root of the quixit directory
            find "$QUIXIT_DIR" -maxdepth 1 -type f | while read -r ROOT_FILE; do
              # Skip protected files
              if echo "$ROOT_FILE" | grep -q "QUIXIT_COMPLETED.txt\|SAMPLE_PACK.tar.gz\|ALL_SONGS.tar.gz\|QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE"; then
                continue
              fi
              
              log "Removing unauthorized file from finalized quixit root: $ROOT_FILE"
              rm -f "$ROOT_FILE"
            done
            
            # Make the entire quixit directory read-only
            chmod -R 555 "$QUIXIT_DIR"
            log "Set entire quixit-$QUIXIT_NUM directory to read-only"
            
            # Ensure the archive files are readable
            chmod 444 "$QUIXIT_DIR/SAMPLE_PACK.tar.gz" "$QUIXIT_DIR/ALL_SONGS.tar.gz"
            log "Ensured archive files are readable in quixit-$QUIXIT_NUM"
          fi
        fi
      done
      
      # Update the current quixit number file after phase transitions
      HIGHEST_NUM=$(find /srv/quixit -maxdepth 1 -type d -name "quixit-*" | sed "s|/srv/quixit/quixit-||" | sort -n | tail -1)
      if [ -z "$HIGHEST_NUM" ]; then
        HIGHEST_NUM=0
      fi
      
      # Update current quixit number file using the locking mechanism
      update_current_quixit_number
    }

    # Function to update current quixit number file with locking
    update_current_quixit_number() {
      # Create a lock file to prevent race conditions
      LOCK_FILE="/tmp/quixit_number_update.lock"
      
      # Try to acquire the lock
      if ! mkdir "$LOCK_FILE" 2>/dev/null; then
        log "Another process is updating quixit number files, skipping this update"
        return 1
      fi
      
      # Ensure the lock is released when the function exits
      trap 'rm -rf "$LOCK_FILE"' EXIT
      
      log "Acquired lock for updating quixit number files"
      
      # Get the highest quixit number from directory names
      HIGHEST_NUM=$(find /srv/quixit -maxdepth 1 -type d -name "quixit-*" | sed "s|/srv/quixit/quixit-||" | sort -n | tail -1)
      if [ -z "$HIGHEST_NUM" ]; then
        HIGHEST_NUM=0
      fi
      
      # Keep only the lowercase file
      echo "$HIGHEST_NUM" > "/srv/quixit/current_quixit_number.txt"
      chmod 444 "/srv/quixit/current_quixit_number.txt"
      
      log "Successfully updated current_quixit_number.txt to $HIGHEST_NUM"
      
      # Release the lock
      rm -rf "$LOCK_FILE"
      trap - EXIT
      
      return 0
    }

    # Run initial phase transition check
    check_phase_transitions

    # Protect system files initially
    protect_system_files

    # Check for unauthorized directories initially
    check_unauthorized_directories

    # Clean up any redundant info files that might exist
    find /srv/quixit -type f -name "QUIXIT_*_SONG_PHASE_INFO.txt" -delete
    find /srv/quixit -type f -name "QUIXIT_*_SAMPLE_PHASE_INFO.txt" -delete
    log "Cleaned up any redundant info files"

    # Run an initial scan of all files to catch any that were added while the watcher was not running
    log "Running initial scan of all files"
    find /srv/quixit -type f | while read -r FILE; do
      # skip system and protected files
      if echo "$FILE" | grep -q "QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE\|QUIXIT_COMPLETED\|SAMPLE_PACK\.tar\.gz\|ALL_SONGS\.tar.gz\|WELCOME_TO_QUIXIT\|current_quixit_number.txt"; then
        continue
      fi
      
      # check if this is a file in a quixit folder
      if echo "$FILE" | grep -q "/quixit/quixit-[0-9]"; then
        QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
        
        # check if file is in samples or songs directory
        if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/" || echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
          log "Checking existing file during initial scan: $FILE"
          check_file "$FILE"
        fi
      fi
    done
    log "Initial file scan complete"

    # Create initial username file
    log "Creating initial username file"
    update_username_file

    # Set up a background job to update usernames every 15 minutes
    (
      while true; do
        sleep 900  # 15 minutes
        log "running scheduled username update"
        update_username_file
      done
    ) &
    USERNAME_UPDATE_PID=$!
    log "Started username update job with PID: $USERNAME_UPDATE_PID"

    # Set up a background job to check for phase transitions every 5 minutes
    (
      while true; do
        sleep 300
        check_phase_transitions
        protect_system_files
        check_unauthorized_directories
        
        # scan all existing files to ensure they comply with rules
        log "performing full scan of all files to ensure compliance with rules"
        find /srv/quixit -type f | while read -r FILE; do
          # skip system and protected files
          if echo "$FILE" | grep -q "QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE\|QUIXIT_COMPLETED\|SAMPLE_PACK\.tar\.gz\|ALL_SONGS\.tar.gz\|WELCOME_TO_QUIXIT\|current_quixit_number.txt"; then
            continue
          fi
          
          # check if this is a file in a quixit folder
          if echo "$FILE" | grep -q "/quixit/quixit-[0-9]"; then
            QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
            
            # check if file is in samples or songs directory
            if echo "$FILE" | grep -q "/$QUIXIT_FOLDER/samples/" || echo "$FILE" | grep -q "/$QUIXIT_FOLDER/songs/"; then
              log "scanning existing file: $FILE"
              check_file "$FILE"
            fi
          fi
        done
        
        # Clean up any redundant info files that might exist
        find /srv/quixit -type f -name "QUIXIT_*_SONG_PHASE_INFO.txt" -delete
        find /srv/quixit -type f -name "QUIXIT_*_SAMPLE_PHASE_INFO.txt" -delete
        log "cleaned up any redundant info files in background job"
      done
    ) &
    BACKGROUND_PID=$!
    log "Started background job with PID: $BACKGROUND_PID"

    # Set up a continuous scanner that checks for invalid files every 1 second
    (
    while true; do
        # Find all samples and songs directories
        find /srv/quixit -type d | grep -E '/(samples|songs)$' | while read -r DIR; do
          # Check for invalid files in this directory
          find "$DIR" -type f -not -path "*/\.*" | while read -r FILE; do
            # Skip if file was recently processed
            FILE_HASH=$(echo "$FILE" | md5sum | cut -d' ' -f1)
            MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
            
            if [ -f "$MARKER_FILE" ]; then
              MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
              if [ "$MARKER_AGE" -lt 5 ]; then  # Reduced from 10 to 5 seconds
                continue
              fi
            fi
            
            # Check for invalid extensions immediately
            if ! echo "$FILE" | grep -q -i -E '\.wav$|\.mp3$|\.ogg$|\.flac$|\.aiff$'; then
              log "Continuous scanner: Removing file with invalid extension: $FILE"
              rm -f "$FILE"
              touch "$MARKER_FILE"
              continue
            fi
            
            # If in songs directory, check for username in filename
            if echo "$FILE" | grep -q "/songs/"; then
              QUIXIT_FOLDER=$(echo "$FILE" | grep -o "quixit-[0-9][0-9]*")
              # Check if we're in songs phase
              if find "/srv/quixit/$QUIXIT_FOLDER" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | grep -q .; then
                FILENAME=$(basename "$FILE")
                
                # Check shared username file instead of hardcoded patterns
                USERNAME_MATCHED=0
                if [ -f "/logs/usernames.txt" ] && [ -s "/logs/usernames.txt" ]; then
                  FILENAME_BASE=$(basename "$FILE")
                  while read -r USERNAME; do
                    if [ -z "$USERNAME" ]; then
                      continue
                    fi
                    
                    if echo "$FILENAME_BASE" | grep -q "_${USERNAME}[.][^.]*$"; then
                      USERNAME_MATCHED=1
                      break
                    fi
                  done < "/logs/usernames.txt"
                fi
                
                # If no username matched and file is older than 5 seconds, remove it
                if [ $USERNAME_MATCHED -eq 0 ]; then
                  # Check if the file has been around for more than 5 seconds
                  FILE_AGE=$(($(date +%s) - $(date -r "$FILE" +%s)))
                  if [ "$FILE_AGE" -gt 5 ]; then
                    # Skip files that already have the warning suffix
                    if echo "$FILENAME_BASE" | grep -q "wrong_username_will_delete_if_not_changed"; then
                      log "File already marked with warning, skipping: $FILE"
                      touch "$MARKER_FILE"
                      continue
                    fi
                    
                    # Use helper function to do a more lenient check
                    USERNAME_IN_FILENAME=0
                    while read -r USERNAME; do
                      if contains_username "$FILENAME_BASE" "$USERNAME"; then
                        USERNAME_IN_FILENAME=1
                        break
                      fi
                    done < "/logs/usernames.txt"
                    
                    if [ $USERNAME_IN_FILENAME -eq 1 ]; then
                      log "Keeping file with username found in filename: $FILE"
                    else
                      log "Continuous scanner: Song file does not contain a known username after 5 seconds, renaming: $FILE"
                      # Get the extension
                      EXTENSION=$(echo "$FILENAME_BASE" | grep -o "\.[^.]\+$")
                      BASENAME_NO_EXT=$(echo "$FILENAME_BASE" | sed "s/$EXTENSION$//")
                      # Create a new filename that keeps the original extension
                      NEW_FILENAME_BASE="${BASENAME_NO_EXT}.wrong_username_will_delete_if_not_changed${EXTENSION}"
                      NEW_FILENAME="$(dirname "$FILE")/$NEW_FILENAME_BASE"
                      # Rename the file instead of removing it
                      mv "$FILE" "$NEW_FILENAME"
                      log "Renamed to: $NEW_FILENAME"
                      # rm -f "$FILE"
                      touch "$MARKER_FILE"
                    fi
                  fi
                fi
              fi
            fi
          done
        done
        
        # Check for files in the root of finalized quixit directories
        find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
          # Check if this quixit is finalized
          if [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ] && [ -f "$QUIXIT_DIR/ALL_SONGS.tar.gz" ]; then
            # Find files in the root of the quixit directory
            find "$QUIXIT_DIR" -maxdepth 1 -type f | while read -r ROOT_FILE; do
              # Skip if file was recently processed
              FILE_HASH=$(echo "$ROOT_FILE" | md5sum | cut -d' ' -f1)
              MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
              
              if [ -f "$MARKER_FILE" ]; then
                MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
                if [ "$MARKER_AGE" -lt 5 ]; then
                  continue
                fi
              fi
              
              # Skip protected files
              if echo "$ROOT_FILE" | grep -q "QUIXIT_COMPLETED.txt\|SAMPLE_PACK.tar.gz\|ALL_SONGS.tar.gz\|QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE"; then
                continue
              fi
              
              log "Continuous scanner: Removing unauthorized file from finalized quixit root: $ROOT_FILE"
              rm -f "$ROOT_FILE"
              touch "$MARKER_FILE"
            done
          fi
        done
        
        # Check for protected files in unauthorized locations
        find /srv/quixit -type f | grep -E "QUIXIT_HAS_BEGUN|SUBMIT_SONGS_BEFORE|QUIXIT_COMPLETED|SAMPLE_PACK\.tar\.gz|ALL_SONGS\.tar\.gz" | while read -r PROTECTED_FILE; do
          # Skip if file was recently processed
          FILE_HASH=$(echo "$PROTECTED_FILE" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          
          if [ -f "$MARKER_FILE" ]; then
            MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
            if [ "$MARKER_AGE" -lt 5 ]; then
              continue
            fi
          fi
          
          # Check if this is in a valid location
          if echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_HAS_BEGUN" || \
             echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SUBMIT_SONGS_BEFORE" || \
             echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_COMPLETED" || \
             echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SAMPLE_PACK\.tar\.gz" || \
             echo "$PROTECTED_FILE" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/ALL_SONGS\.tar\.gz"; then
            
            # This is in the right place, ensure it has the correct permissions
            chmod 444 "$PROTECTED_FILE"
          else
            # This is not in the right place, so remove it
            log "Continuous scanner: Removing protected file in unauthorized location: $PROTECTED_FILE"
            rm -f "$PROTECTED_FILE"
            touch "$MARKER_FILE"
          fi
        done
        
        # Check welcome file
        if [ -f "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt" ]; then
          # Skip if file was recently processed
          FILE_HASH=$(echo "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          
          if [ -f "$MARKER_FILE" ]; then
            MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
            if [ "$MARKER_AGE" -lt 5 ]; then
              continue
            fi
          fi
          
          # Check if content has been modified
          if ! grep -q "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE" "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"; then
            log "Continuous scanner: Welcome file content has been modified, restoring original content"
            echo "WELCOME TO QUIXIT MUSIC COLLABORATION CHALLENGE" > "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 14 days, and then receive constructive criticism from fellow peers on their track." >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "how it works:" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "1. upload samples during the sample submission phase" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "2. download the sample pack when it becomes available" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "3. create your track using only the provided samples" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "4. upload your finished track during the song submission phase" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "5. download and listen to everyone's tracks when the challenge is complete" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "all previous quixit challenges are available in read-only mode." >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "if you enjoy quixit, please consider supporting the project with a donation:" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
            echo "https://www.paypal.com/donate/?hosted_button_id=T73SWSVDGBFH8" >> "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          fi
          
          # Ensure permissions are set
          chmod 444 "/srv/quixit/WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"
          touch "$MARKER_FILE"
        fi
        
        # Check current_quixit_number.txt
        if [ -f "/srv/quixit/current_quixit_number.txt" ]; then
          # Skip if file was recently processed
          FILE_HASH=$(echo "/srv/quixit/current_quixit_number.txt" | md5sum | cut -d' ' -f1)
          MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
          
          if [ -f "$MARKER_FILE" ]; then
            MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
            if [ "$MARKER_AGE" -lt 5 ]; then
              continue
            fi
          fi
          
          # Update the current quixit number file using the locking mechanism
          update_current_quixit_number
          touch "$MARKER_FILE"
        fi
        
        # Explicitly check all protected files in all quixit directories
        find /srv/quixit -type d -name "quixit-*" | while read -r QUIXIT_DIR; do
          QUIXIT_NUM=$(basename "$QUIXIT_DIR" | cut -d"-" -f2)
          
          # Check QUIXIT_COMPLETED.txt
          if [ -f "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ]; then
            FILE_HASH=$(echo "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" | md5sum | cut -d' ' -f1)
            MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
            
            if [ -f "$MARKER_FILE" ]; then
              MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
              if [ "$MARKER_AGE" -ge 5 ]; then
                log "Continuous scanner: Checking QUIXIT_COMPLETED.txt in $QUIXIT_DIR"
                if [ ! -s "$QUIXIT_DIR/QUIXIT_COMPLETED.txt" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - COMPLETED" "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"; then
                  log "Continuous scanner: QUIXIT_COMPLETED.txt content has been modified, restoring content"
                  COMPLETION_DATE=$(date +"%Y-%m-%d")
                  echo "QUIXIT #$QUIXIT_NUM - COMPLETED" > "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "This quixit challenge is now complete!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "Completed on: $COMPLETION_DATE" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "You can download:" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "- SAMPLE_PACK.tar.gz - All samples used in this challenge" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "- ALL_SONGS.tar.gz - All submitted tracks" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                  echo "Thank you for participating!" >> "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                fi
                chmod 444 "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
                touch "$MARKER_FILE"
              fi
            else
              log "Continuous scanner: First check of QUIXIT_COMPLETED.txt in $QUIXIT_DIR"
              chmod 444 "$QUIXIT_DIR/QUIXIT_COMPLETED.txt"
              touch "$MARKER_FILE"
            fi
          fi
          
          # Check SUBMIT_SAMPLES_BEFORE_* files
          find "$QUIXIT_DIR" -maxdepth 1 -name "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_*" -type f | while read -r SAMPLE_FILE; do
            FILE_HASH=$(echo "$SAMPLE_FILE" | md5sum | cut -d' ' -f1)
            MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
            
            if [ -f "$MARKER_FILE" ]; then
              MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
              if [ "$MARKER_AGE" -ge 5 ]; then
                log "Continuous scanner: Checking sample phase file in $QUIXIT_DIR"
                # Always restore content to ensure it hasn't been tampered with
                DEADLINE=$(basename "$SAMPLE_FILE" | sed 's/QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_//')
                echo "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" > "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "Upload your samples before: $DEADLINE" >> "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "Guidelines:" >> "$SAMPLE_FILE"
                echo "- Upload audio samples to the 'samples' directory" >> "$SAMPLE_FILE"
                echo "- Keep samples to a max size of 20mb each, no larger" >> "$SAMPLE_FILE"
                echo "- No more than 5 samples per user" >> "$SAMPLE_FILE"
                echo "" >> "$SAMPLE_FILE"
                echo "After the deadline, all samples will be compiled into a sample pack for the song phase." >> "$SAMPLE_FILE"
                chmod 444 "$SAMPLE_FILE"
                touch "$MARKER_FILE"
              fi
            else
              log "Continuous scanner: First check of sample phase file in $QUIXIT_DIR"
              # Always restore content on first check
              DEADLINE=$(basename "$SAMPLE_FILE" | sed 's/QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" > "$SAMPLE_FILE"
              echo "" >> "$SAMPLE_FILE"
              echo "Upload your samples before: $DEADLINE" >> "$SAMPLE_FILE"
              echo "" >> "$SAMPLE_FILE"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$SAMPLE_FILE"
              echo "" >> "$SAMPLE_FILE"
              echo "Guidelines:" >> "$SAMPLE_FILE"
              echo "- Upload audio samples to the 'samples' directory" >> "$SAMPLE_FILE"
              echo "- Keep samples to a max size of 20mb each, no larger" >> "$SAMPLE_FILE"
              echo "- No more than 5 samples per user" >> "$SAMPLE_FILE"
              echo "" >> "$SAMPLE_FILE"
              echo "After the deadline, all samples will be compiled into a sample pack for the song phase." >> "$SAMPLE_FILE"
              chmod 444 "$SAMPLE_FILE"
              touch "$MARKER_FILE"
            fi
          done
          
          # Check SUBMIT_SONGS_BEFORE_* files
          find "$QUIXIT_DIR" -maxdepth 1 -name "SUBMIT_SONGS_BEFORE_*" -type f | while read -r SONG_FILE; do
            FILE_HASH=$(echo "$SONG_FILE" | md5sum | cut -d' ' -f1)
            MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
            
            if [ -f "$MARKER_FILE" ]; then
              MARKER_AGE=$(($(date +%s) - $(date -r "$MARKER_FILE" +%s)))
              if [ "$MARKER_AGE" -ge 5 ]; then
                log "Continuous scanner: Checking song phase file in $QUIXIT_DIR"
                # Always restore content to ensure it hasn't been tampered with
                DEADLINE=$(basename "$SONG_FILE" | sed 's/SUBMIT_SONGS_BEFORE_//')
                echo "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" > "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "Upload your finished track before: $DEADLINE" >> "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "Guidelines:" >> "$SONG_FILE"
                echo "- Upload your finished track to the 'songs' directory" >> "$SONG_FILE"
                echo "- Use ONLY samples from the provided sample pack" >> "$SONG_FILE"
                echo "- Include your username in the filename (e.g. my_track_username.mp3)" >> "$SONG_FILE"
                echo "" >> "$SONG_FILE"
                echo "After the deadline, all tracks will be compiled into a downloadable archive." >> "$SONG_FILE"
                chmod 444 "$SONG_FILE"
                touch "$MARKER_FILE"
              fi
            else
              log "Continuous scanner: First check of song phase file in $QUIXIT_DIR"
              # Always restore content on first check
              DEADLINE=$(basename "$SONG_FILE" | sed 's/SUBMIT_SONGS_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" > "$SONG_FILE"
              echo "" >> "$SONG_FILE"
              echo "Upload your finished track before: $DEADLINE" >> "$SONG_FILE"
              echo "" >> "$SONG_FILE"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$SONG_FILE"
              echo "" >> "$SONG_FILE"
              echo "Guidelines:" >> "$SONG_FILE"
              echo "- Upload your finished track to the 'songs' directory" >> "$SONG_FILE"
              echo "- Use ONLY samples from the provided sample pack" >> "$SONG_FILE"
              echo "- Include your username in the filename (e.g. my_track_username.mp3)" >> "$SONG_FILE"
              echo "" >> "$SONG_FILE"
              echo "After the deadline, all tracks will be compiled into a downloadable archive." >> "$SONG_FILE"
              chmod 444 "$SONG_FILE"
              touch "$MARKER_FILE"
            fi
          done
        done
        
        # Sleep for a short time before next scan
        sleep 2
        
        # Check for files with wrong usernames that need to be removed after 24 hours
        find /srv/quixit -type f -name "*.wrong_username_will_delete_if_not_changed*" | while read -r WRONG_FILE; do
          # Skip files with multiple warning suffixes
          if echo "$WRONG_FILE" | grep -o "wrong_username_will_delete_if_not_changed" | wc -l | grep -q -v "^1$"; then
            log "File has multiple warning suffixes, skipping cleanup check: $WRONG_FILE"
            continue
          fi
          
          # Check if this file is older than 24 hours
          FILE_AGE=$(($(date +%s) - $(date -r "$WRONG_FILE" +%s)))
          if [ "$FILE_AGE" -gt 86400 ]; then  # 86400 seconds = 24 hours
            log "Removing file with wrong username after 24 hours: $WRONG_FILE"
            rm -f "$WRONG_FILE"
          else
            HOURS_LEFT=$(( (86400 - FILE_AGE) / 3600 ))
            log "File with wrong username will be removed in approximately $HOURS_LEFT hours: $WRONG_FILE"
          fi
        done
      done
    ) &
    CONTINUOUS_SCANNER_PID=$!
    log "Started continuous scanner with PID: $CONTINUOUS_SCANNER_PID"

    # Update the trap to kill all background processes
    trap 'kill $BACKGROUND_PID $CONTINUOUS_SCANNER_PID $USERNAME_UPDATE_PID 2>/dev/null; log "Killed background jobs"; exit' INT TERM EXIT

    # main loop that restarts inotifywait if it exits
    log "Starting main file watch loop"
    while true; do
      log "Setting up inotifywait to monitor file events"
      # Use inotifywait with -m flag to keep it running continuously
      inotifywait -m -r -e close_write,moved_to,modify,attrib,create /srv/quixit 2>/dev/null | while read -r DIR EVENT FILE; do
        FULL_PATH="${DIR}${FILE}"
        log "Event: $EVENT, file: $FULL_PATH"
        
        # Skip if this file was recently processed
        if was_recently_processed "$FULL_PATH"; then
          continue
        fi
        
        # Check if this is a directory creation event
        if [ -d "$FULL_PATH" ] && echo "$EVENT" | grep -q "CREATE"; then
          log "Directory created: $FULL_PATH"
          
          # Check if this is an allowed directory
          if echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*$" || \
             echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/samples$" || \
             echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/songs$"; then
            # This is an allowed directory structure, likely created by admin
            log "Allowed directory structure detected, keeping directory"
          else
            # This is an unauthorized directory created by a user
            log "Unauthorized directory created, removing: $FULL_PATH"
            rm -rf "$FULL_PATH"
          fi
          continue
        fi
        
        # Skip directories and temporary files for regular file checks
        if [ -d "$FULL_PATH" ] || echo "$FILE" | grep -q "\.tmp$"; then
          log "Skipping directory or temporary file"
          continue
        fi
        
        # Immediate check for invalid file extensions in samples/songs directories
        if echo "$EVENT" | grep -q "CREATE" && (echo "$FULL_PATH" | grep -q "/samples/" || echo "$FULL_PATH" | grep -q "/songs/"); then
          # Check file extension immediately without any delay
          if ! echo "$FULL_PATH" | grep -q -i -E '\.wav$|\.mp3$|\.ogg$|\.flac$|\.aiff$'; then
            log "Immediate deletion: File with invalid extension detected in samples/songs directory: $FULL_PATH"
            rm -f "$FULL_PATH"
            # Mark as processed to avoid duplicate processing
            FILE_HASH=$(echo "$FULL_PATH" | md5sum | cut -d' ' -f1)
            MARKER_FILE="$PROCESSED_FILES_DIR/$FILE_HASH"
            touch "$MARKER_FILE"
            continue
          fi
        fi
        
        # Check if this is a system file that was modified
        if echo "$EVENT" | grep -q "MODIFY\|ATTRIB"; then
          # Check if it is a protected file
          if echo "$FULL_PATH" | grep -q "QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE\|QUIXIT_COMPLETED\|SAMPLE_PACK\.tar\.gz\|ALL_SONGS\.tar.gz\|WELCOME_TO_QUIXIT"; then
            log "Detected modification to protected file: $FULL_PATH, restoring permissions"
            chmod 444 "$FULL_PATH"
            
            # Special handling for welcome file
            if echo "$FULL_PATH" | grep -q "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE.txt"; then
              log "Detected modification to welcome file, checking content"
              if ! grep -q "WELCOME_TO_QUIXIT_MUSIC_COLLABORATION_CHALLENGE" "$FULL_PATH"; then
                log "Welcome file content has been modified, restoring original content"
                echo "WELCOME TO QUIXIT MUSIC COLLABORATION CHALLENGE" > "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "quixit is a regular event that allows everyone to work off of a single pack of audio samples, make a track in 14 days, and then receive constructive criticism from fellow peers on their track." >> "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "how it works:" >> "$FULL_PATH"
                echo "1. upload samples during the sample submission phase" >> "$FULL_PATH"
                echo "2. download the sample pack when it becomes available" >> "$FULL_PATH"
                echo "3. create your track using only the provided samples" >> "$FULL_PATH"
                echo "4. upload your finished track during the song submission phase" >> "$FULL_PATH"
                echo "5. download and listen to everyone's tracks when the challenge is complete" >> "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "important: when uploading a finished track, include username exactly as registered, case sensitive; for example, 'mytrack_UserName.mp3', note the underscore immediately precedes the username." >> "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "all previous quixit challenges are available in read-only mode." >> "$FULL_PATH"
                chmod 444 "$FULL_PATH"
              fi
              continue
            fi
            
            # Special handling for QUIXIT_HAS_BEGUN files
            if echo "$FULL_PATH" | grep -q "QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_"; then
              log "Detected modification to sample phase file, restoring content"
              QUIXIT_NUM=$(basename "$(dirname "$FULL_PATH")" | cut -d"-" -f2)
              DEADLINE=$(basename "$FULL_PATH" | sed 's/QUIXIT_HAS_BEGUN_UPLOAD_SAMPLES_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SAMPLE SUBMISSION PHASE" > "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Upload your samples before: $DEADLINE" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Guidelines:" >> "$FULL_PATH"
              echo "- Upload audio samples to the 'samples' directory" >> "$FULL_PATH"
              echo "- Keep samples to a max size of 20mb each, no larger" >> "$FULL_PATH"
              echo "- No more than 5 samples per user" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "After the deadline, all samples will be compiled into a sample pack for the song phase." >> "$FULL_PATH"
              chmod 444 "$FULL_PATH"
              continue
            fi
            
            # Special handling for SUBMIT_SONGS_BEFORE files
            if echo "$FULL_PATH" | grep -q "SUBMIT_SONGS_BEFORE_"; then
              log "Detected modification to song phase file, restoring content"
              QUIXIT_NUM=$(basename "$(dirname "$FULL_PATH")" | cut -d"-" -f2)
              DEADLINE=$(basename "$FULL_PATH" | sed 's/SUBMIT_SONGS_BEFORE_//')
              echo "QUIXIT #$QUIXIT_NUM - SONG SUBMISSION PHASE" > "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Upload your finished track before: $DEADLINE" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Accepted file formats: .wav, .mp3, .ogg, .flac, .aiff" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "Guidelines:" >> "$FULL_PATH"
              echo "- Upload your finished track to the 'songs' directory" >> "$FULL_PATH"
              echo "- Use ONLY samples from the provided sample pack" >> "$FULL_PATH"
              echo "- Include your username in the filename (e.g. my_track_username.mp3)" >> "$FULL_PATH"
              echo "" >> "$FULL_PATH"
              echo "After the deadline, all tracks will be compiled into a downloadable archive." >> "$FULL_PATH"
              chmod 444 "$FULL_PATH"
              continue
            fi
            
            # Special handling for QUIXIT_COMPLETED.txt
            if echo "$FULL_PATH" | grep -q "QUIXIT_COMPLETED.txt"; then
              log "Detected modification to completion file, checking content"
              QUIXIT_NUM=$(basename "$(dirname "$FULL_PATH")" | cut -d"-" -f2)
              if [ ! -s "$FULL_PATH" ] || ! grep -q "QUIXIT #$QUIXIT_NUM - COMPLETED" "$FULL_PATH"; then
                log "Completion file content has been modified, restoring content"
                COMPLETION_DATE=$(date +"%Y-%m-%d")
                echo "QUIXIT #$QUIXIT_NUM - COMPLETED" > "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "This quixit challenge is now complete!" >> "$FULL_PATH"
                echo "Completed on: $COMPLETION_DATE" >> "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "You can download:" >> "$FULL_PATH"
                echo "- SAMPLE_PACK.tar.gz - All samples used in this challenge" >> "$FULL_PATH"
                echo "- ALL_SONGS.tar.gz - All submitted tracks" >> "$FULL_PATH"
                echo "" >> "$FULL_PATH"
                echo "Thank you for participating!" >> "$FULL_PATH"
                chmod 444 "$FULL_PATH"
              fi
              continue
            fi
            continue
          fi
          
          # Special handling for current_quixit_number.txt
          if echo "$FULL_PATH" | grep -q "current_quixit_number.txt"; then
            log "Detected modification to quixit number file, restoring content and permissions"
            
            # Use the locking mechanism to update the quixit number file
            update_current_quixit_number
            continue
          fi
        fi
        
        # For new files, check if they are allowed
        if echo "$EVENT" | grep -q "CLOSE_WRITE\|MOVED_TO\|CREATE"; then
          # Prioritize CREATE events for faster response
          IS_CREATE_EVENT="false"
          IS_PRIORITY="false"
          
          if echo "$EVENT" | grep -q "CREATE"; then
            IS_CREATE_EVENT="true"
            log "Prioritizing CREATE event for faster response"
          fi
          
          # Check if this is a protected file name that was created by a user
          if echo "$FILE" | grep -q -E "QUIXIT_HAS_BEGUN|SUBMIT_SONGS_BEFORE|QUIXIT_COMPLETED|SAMPLE_PACK\.tar\.gz|ALL_SONGS\.tar\.gz"; then
            # Extract quixit folder if applicable
            QUIXIT_FOLDER=""
            if echo "$FULL_PATH" | grep -q "/quixit/quixit-[0-9]"; then
              QUIXIT_FOLDER=$(echo "$FULL_PATH" | grep -o "quixit-[0-9][0-9]*")
              log "Detected creation of protected file name in $QUIXIT_FOLDER: $FULL_PATH"
              
              # Check if this is an admin-created file (we can't really tell, but we can check if it's in the right place)
              if echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_HAS_BEGUN" || \
                 echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SUBMIT_SONGS_BEFORE" || \
                 echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/QUIXIT_COMPLETED" || \
                 echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/SAMPLE_PACK\.tar\.gz" || \
                 echo "$FULL_PATH" | grep -q "^/srv/quixit/quixit-[0-9][0-9]*/ALL_SONGS\.tar\.gz"; then
                
                # This is in the right place, so it might be legitimate
                # Set proper permissions and trigger phase transition check
                log "Setting proper permissions for protected file: $FULL_PATH"
                chmod 444 "$FULL_PATH"
                
                # Trigger phase transition check to handle the new file
                check_phase_transitions
              else
                # This is not in the right place, so remove it
                log "Removing unauthorized protected file name: $FULL_PATH"
                rm -f "$FULL_PATH"
              fi
              continue
            fi
          fi
          
          # Check if this is a file in the root of a finalized quixit directory
          if echo "$FULL_PATH" | grep -q "/quixit/quixit-[0-9][0-9]*/" && ! echo "$FULL_PATH" | grep -q "/samples/" && ! echo "$FULL_PATH" | grep -q "/songs/"; then
            QUIXIT_FOLDER=$(echo "$FULL_PATH" | grep -o "quixit-[0-9][0-9]*")
            
            # Check if this quixit is finalized
            if [ -f "/srv/quixit/$QUIXIT_FOLDER/QUIXIT_COMPLETED.txt" ] && [ -f "/srv/quixit/$QUIXIT_FOLDER/ALL_SONGS.tar.gz" ]; then
              # Skip protected files
              if ! echo "$FULL_PATH" | grep -q "QUIXIT_COMPLETED.txt\|SAMPLE_PACK.tar.gz\|ALL_SONGS.tar.gz\|QUIXIT_HAS_BEGUN\|SUBMIT_SONGS_BEFORE"; then
                log "File uploaded to root of finalized quixit directory, removing: $FULL_PATH"
                rm -f "$FULL_PATH"
                continue
              fi
            fi
          fi
          
          # Give highest priority to files in samples or songs directories
          if echo "$FULL_PATH" | grep -q "/samples/" || echo "$FULL_PATH" | grep -q "/songs/"; then
            IS_PRIORITY="true"
            log "High priority file in samples/songs directory, processing immediately"
            
            # For highest priority files, process them in a background process to avoid blocking
            # This ensures we can continue processing other events while this file is being checked
            (
              check_file "$FULL_PATH" "$IS_CREATE_EVENT" "$IS_PRIORITY"
            ) &
          else
          # Check if the file is allowed based on phase
            check_file "$FULL_PATH" "$IS_CREATE_EVENT" "$IS_PRIORITY"
          fi
        fi
        
        # Protect system files after file operations
        protect_system_files
      done
      
      # If inotifywait exits, log it and restart after a short delay
      log "inotifywait exited, restarting in 5 seconds..."
      sleep 5
      log "Restarting inotifywait..."
    done
    EOF

      # Make the watcher script executable
      chmod +x /tmp/watcher.sh
      
    # Execute the watcher script with exec to replace the current process
      exec /tmp/watcher.sh

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: quixit
  namespace: quixit
  labels:
    app: quixit
spec:
  replicas: 1
  revisionHistoryLimit: 3
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: quixit
  template:
    metadata:
      labels:
        app: quixit
    spec:
      containers:
        - name: quixit
          image: filebrowser/filebrowser:v2.52.0
          imagePullPolicy: IfNotPresent
          env:
            - name: QUIXIT_HOST
              valueFrom:
                secretKeyRef:
                  name: quixit-admin-credentials
                  key: host
            - name: QUIXIT_USER
              valueFrom:
                secretKeyRef:
                  name: quixit-admin-credentials
                  key: admin-user
            - name: QUIXIT_PW
              valueFrom:
                secretKeyRef:
                  name: quixit-admin-credentials
                  key: admin-password
          volumeMounts:
            - name: quixit
              mountPath: /srv
              subPath: files
            - name: quixit
              mountPath: /database
              subPath: database
            - name: quixit
              mountPath: /branding
              subPath: branding
            - name: quixit
              mountPath: /logs
              subPath: logs
            - name: quixit-scripts
              mountPath: /scripts
          ports:
            - name: http
              containerPort: 44301
              protocol: TCP
          resources:
            requests:
              cpu: 500m
              memory: 512Mi
            limits:
              memory: 512Mi
          command: ["/bin/sh", "-c", "/scripts/init-quixit.sh"]
        - name: file-watcher
          image: alpine/curl:8.12.1
          imagePullPolicy: IfNotPresent
          command: ["/bin/sh", "-c"]
          args:
            - |
              cp /scripts/wrapper.sh /tmp/wrapper.sh
              chmod +x /tmp/wrapper.sh
              exec /tmp/wrapper.sh
          env:
            - name: QUIXIT_USER
              valueFrom:
                secretKeyRef:
                  name: quixit-admin-credentials
                  key: admin-user
            - name: QUIXIT_PW
              valueFrom:
                secretKeyRef:
                  name: quixit-admin-credentials
                  key: admin-password
          volumeMounts:
            - name: quixit
              mountPath: /srv
              subPath: files
            - name: quixit
              mountPath: /logs
              subPath: logs
            - name: quixit-scripts
              mountPath: /scripts
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
        - name: log-rotator
          image: alpine:3.21.3
          imagePullPolicy: IfNotPresent
          command: ["/bin/sh", "-c"]
          args:
            - |
              # install logrotate
              apk add --no-cache logrotate

              # create logrotate config
              cat > /etc/logrotate.d/quixit << EOF
              # use root user and group for rotation regardless of directory permissions
              su root root

              /logs/watcher.log {
                size 20M
                rotate 24
                compress
                missingok
                notifempty
                copytruncate
                dateext
                dateformat -%Y%m%d-%H%M%S
                create 0644 root root
                postrotate
                  echo "[$(date)] watcher.log rotated" >> /logs/logrotate.log
                endscript
              }

              /logs/filebrowser.log {
                size 5M
                rotate 2
                compress
                missingok
                notifempty
                copytruncate
                dateext
                dateformat -%Y%m%d-%H%M%S
                create 0644 root root
                postrotate
                  echo "[$(date)] filebrowser.log rotated" >> /logs/logrotate.log
                endscript
              }
              EOF

              # check if logs need rotation on startup
              echo "[$(date)] Checking logs on startup" >> /logs/logrotate.log

              # check for existing rotated logs to avoid duplicates
              EXISTING_ROTATED_LOGS=$(find /logs -name "*.gz" | wc -l)
              if [ "$EXISTING_ROTATED_LOGS" -gt 0 ]; then
                echo "[$(date)] Found $EXISTING_ROTATED_LOGS existing rotated logs, skipping initial rotation" >> /logs/logrotate.log
              else
                # only force rotation if logs exceed size limits and no rotated logs exist
                WATCHER_LOG_SIZE=0
                FILEBROWSER_LOG_SIZE=0
                
                if [ -f "/logs/watcher.log" ]; then
                  WATCHER_LOG_SIZE=$(stat -c%s "/logs/watcher.log" 2>/dev/null || echo "0")
                fi
                
                if [ -f "/logs/filebrowser.log" ]; then
                  FILEBROWSER_LOG_SIZE=$(stat -c%s "/logs/filebrowser.log" 2>/dev/null || echo "0")
                fi
                
                # 20M = 20971520 bytes, 5M = 5242880 bytes
                if [ "$WATCHER_LOG_SIZE" -gt 20971520 ] || [ "$FILEBROWSER_LOG_SIZE" -gt 5242880 ]; then
                  echo "[$(date)] Logs exceed size limits, rotating now" >> /logs/logrotate.log
                  logrotate -v /etc/logrotate.d/quixit
                else
                  echo "[$(date)] Logs are within size limits, skipping initial rotation" >> /logs/logrotate.log
                fi
              fi

              # run logrotate every 15 minutes
              while true; do
                sleep 900
                echo "[$(date)] Running scheduled logrotate check" >> /logs/logrotate.log
                logrotate -v /etc/logrotate.d/quixit
              done
          volumeMounts:
            - name: quixit
              mountPath: /logs
              subPath: logs
          resources:
            requests:
              cpu: 50m
              memory: 64Mi
            limits:
              memory: 128Mi
      volumes:
        - name: quixit
          persistentVolumeClaim:
            claimName: quixit
        - name: quixit-scripts
          configMap:
            name: quixit-scripts
            defaultMode: 0755
